<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>小站</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2020-05-30T16:13:46.091Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>小羽</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>autopep8 模块</title>
    <link href="http://yoursite.com/2020/05/13/autopep8%20%E6%A8%A1%E5%9D%97/"/>
    <id>http://yoursite.com/2020/05/13/autopep8%20%E6%A8%A1%E5%9D%97/</id>
    <published>2020-05-13T14:59:45.000Z</published>
    <updated>2020-05-30T16:13:46.091Z</updated>
    
    <content type="html"><![CDATA[<p>这是一个可以让python代码自动规范化的开源库，写好的python看着比较混乱，可以使用该库直接改善代码布局，提升可读性。也可以在IDE内（比如PyCharm）中预先配置该库的插件。</p><h4 id="PEP8"><a href="#PEP8" class="headerlink" title="PEP8"></a>PEP8</h4><p>python编程规范，是一种一致性的风格倡议，可以让代码看起来更整洁（当然，如果规范的规则破坏你原有整齐的风格，可以忽略它）。其中规则有：</p><ul><li>行限制的最大字符数为79</li><li>每一级缩进使用4个空格</li><li>导入通常在分开的行</li><li>优先修改注释</li><li>……</li></ul><p>PEP8 规范原文链接：<a href="http://legacy.python.org/dev/peps/pep-0008/" target="_blank" rel="noopener">官网 </a>    <a href="https://blog.csdn.net/ratsniper/article/details/78954852" target="_blank" rel="noopener">中文版</a></p><h4 id="autopep8"><a href="#autopep8" class="headerlink" title="autopep8"></a>autopep8</h4><p>首先记着安装该库：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip/pip3 install autopep8   <span class="comment">#python2 或 python3</span></span><br></pre></td></tr></table></figure><p>对于需要改的python程序，比如test.py，在命令行输入如下命令：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">autopep8 -i -a test.py 或 autopep8 --<span class="keyword">in</span>-place --aggressive test.py</span><br><span class="line"><span class="comment"># -i,--in-place 在原文件修改</span></span><br><span class="line"><span class="comment"># -a,--aggressive  允许非空格的改变</span></span><br><span class="line">autopep8 -v test.py</span><br><span class="line"><span class="comment"># -v 表示打印出修改内容</span></span><br><span class="line">autopep8 -i -a -a test.py</span><br><span class="line"><span class="comment"># 多个 -a 提升修改级别，一个-a会忽略一些问题</span></span><br></pre></td></tr></table></figure><p>你可以通过<code>--help</code>参数来获取帮助，比如其他参数的使用和含义。<br>autopep8修改的问题有如下通过<code>--select errors</code>参数可以指定前面的序号来修改指定问题： </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line">E101 - Reindent all lines.</span><br><span class="line">E11  - Fix indentation.</span><br><span class="line">E121 - Fix indentation to be a multiple of four.</span><br><span class="line">E122 - Add absent indentation <span class="keyword">for</span> hanging indentation.</span><br><span class="line">E123 - Align closing bracket to match opening bracket.</span><br><span class="line">E124 - Align closing bracket to match visual indentation.</span><br><span class="line">E125 - Indent to distinguish line <span class="keyword">from</span> next logical line.</span><br><span class="line">E126 - Fix over-indented hanging indentation.</span><br><span class="line">E127 - Fix visual indentation.</span><br><span class="line">E128 - Fix visual indentation.</span><br><span class="line">E129 - Fix visual indentation.</span><br><span class="line">E131 - Fix hanging indent <span class="keyword">for</span> unaligned continuation line.</span><br><span class="line">E133 - Fix missing indentation <span class="keyword">for</span> closing bracket.</span><br><span class="line">E20  - Remove extraneous whitespace.</span><br><span class="line">E211 - Remove extraneous whitespace.</span><br><span class="line">E22  - Fix extraneous whitespace around keywords.</span><br><span class="line">E224 - Remove extraneous whitespace around operator.</span><br><span class="line">E225 - Fix missing whitespace around operator.</span><br><span class="line">E226 - Fix missing whitespace around arithmetic operator.</span><br><span class="line">E227 - Fix missing whitespace around bitwise/shift operator.</span><br><span class="line">E228 - Fix missing whitespace around modulo operator.</span><br><span class="line">E231 - Add missing whitespace.</span><br><span class="line">E241 - Fix extraneous whitespace around keywords.</span><br><span class="line">E242 - Remove extraneous whitespace around operator.</span><br><span class="line">E251 - Remove whitespace around parameter <span class="string">'='</span> sign.</span><br><span class="line">E252 - Missing whitespace around parameter equals.</span><br><span class="line">E26  - Fix spacing after comment hash <span class="keyword">for</span> inline comments.</span><br><span class="line">E265 - Fix spacing after comment hash <span class="keyword">for</span> block comments.</span><br><span class="line">E266 - Fix too many leading <span class="string">'#'</span> <span class="keyword">for</span> block comments.</span><br><span class="line">E27  - Fix extraneous whitespace around keywords.</span><br><span class="line">E301 - Add missing blank line.</span><br><span class="line">E302 - Add missing <span class="number">2</span> blank lines.</span><br><span class="line">E303 - Remove extra blank lines.</span><br><span class="line">E304 - Remove blank line following function decorator.</span><br><span class="line">E305 - Expected <span class="number">2</span> blank lines after end of function <span class="keyword">or</span> <span class="class"><span class="keyword">class</span>.</span></span><br><span class="line"><span class="class"><span class="title">E306</span> - <span class="title">Expected</span> 1 <span class="title">blank</span> <span class="title">line</span> <span class="title">before</span> <span class="title">a</span> <span class="title">nested</span> <span class="title">definition</span>.</span></span><br><span class="line"><span class="class"><span class="title">E401</span> - <span class="title">Put</span> <span class="title">imports</span> <span class="title">on</span> <span class="title">separate</span> <span class="title">lines</span>.</span></span><br><span class="line"><span class="class"><span class="title">E402</span> - <span class="title">Fix</span> <span class="title">module</span> <span class="title">level</span> <span class="title">import</span> <span class="title">not</span> <span class="title">at</span> <span class="title">top</span> <span class="title">of</span> <span class="title">file</span></span></span><br><span class="line"><span class="class"><span class="title">E501</span> - <span class="title">Try</span> <span class="title">to</span> <span class="title">make</span> <span class="title">lines</span> <span class="title">fit</span> <span class="title">within</span> --<span class="title">max</span>-<span class="title">line</span>-<span class="title">length</span> <span class="title">characters</span>.</span></span><br><span class="line"><span class="class"><span class="title">E502</span> - <span class="title">Remove</span> <span class="title">extraneous</span> <span class="title">escape</span> <span class="title">of</span> <span class="title">newline</span>.</span></span><br><span class="line"><span class="class"><span class="title">E701</span> - <span class="title">Put</span> <span class="title">colon</span>-<span class="title">separated</span> <span class="title">compound</span> <span class="title">statement</span> <span class="title">on</span> <span class="title">separate</span> <span class="title">lines</span>.</span></span><br><span class="line"><span class="class"><span class="title">E70</span>  - <span class="title">Put</span> <span class="title">semicolon</span>-<span class="title">separated</span> <span class="title">compound</span> <span class="title">statement</span> <span class="title">on</span> <span class="title">separate</span> <span class="title">lines</span>.</span></span><br><span class="line"><span class="class"><span class="title">E711</span> - <span class="title">Fix</span> <span class="title">comparison</span> <span class="title">with</span> <span class="title">None</span>.</span></span><br><span class="line"><span class="class"><span class="title">E712</span> - <span class="title">Fix</span> <span class="title">comparison</span> <span class="title">with</span> <span class="title">boolean</span>.</span></span><br><span class="line"><span class="class"><span class="title">E713</span> - <span class="title">Use</span> '<span class="title">not</span> <span class="title">in</span>' <span class="title">for</span> <span class="title">test</span> <span class="title">for</span> <span class="title">membership</span>.</span></span><br><span class="line"><span class="class"><span class="title">E714</span> - <span class="title">Use</span> '<span class="title">is</span> <span class="title">not</span>' <span class="title">test</span> <span class="title">for</span> <span class="title">object</span> <span class="title">identity</span>.</span></span><br><span class="line"><span class="class"><span class="title">E721</span> - <span class="title">Use</span> "<span class="title">isinstance</span><span class="params">()</span>" <span class="title">instead</span> <span class="title">of</span> <span class="title">comparing</span> <span class="title">types</span> <span class="title">directly</span>.</span></span><br><span class="line"><span class="class"><span class="title">E722</span> - <span class="title">Fix</span> <span class="title">bare</span> <span class="title">except</span>.</span></span><br><span class="line"><span class="class"><span class="title">E731</span> - <span class="title">Use</span> <span class="title">a</span> <span class="title">def</span> <span class="title">when</span> <span class="title">use</span> <span class="title">do</span> <span class="title">not</span> <span class="title">assign</span> <span class="title">a</span> <span class="title">lambda</span> <span class="title">expression</span>.</span></span><br><span class="line"><span class="class"><span class="title">W291</span> - <span class="title">Remove</span> <span class="title">trailing</span> <span class="title">whitespace</span>.</span></span><br><span class="line"><span class="class"><span class="title">W292</span> - <span class="title">Add</span> <span class="title">a</span> <span class="title">single</span> <span class="title">newline</span> <span class="title">at</span> <span class="title">the</span> <span class="title">end</span> <span class="title">of</span> <span class="title">the</span> <span class="title">file</span>.</span></span><br><span class="line"><span class="class"><span class="title">W293</span> - <span class="title">Remove</span> <span class="title">trailing</span> <span class="title">whitespace</span> <span class="title">on</span> <span class="title">blank</span> <span class="title">line</span>.</span></span><br><span class="line"><span class="class"><span class="title">W391</span> - <span class="title">Remove</span> <span class="title">trailing</span> <span class="title">blank</span> <span class="title">lines</span>.</span></span><br><span class="line"><span class="class"><span class="title">W503</span> - <span class="title">Fix</span> <span class="title">line</span> <span class="title">break</span> <span class="title">before</span> <span class="title">binary</span> <span class="title">operator</span>.</span></span><br><span class="line"><span class="class"><span class="title">W504</span> - <span class="title">Fix</span> <span class="title">line</span> <span class="title">break</span> <span class="title">after</span> <span class="title">binary</span> <span class="title">operator</span>.</span></span><br><span class="line"><span class="class"><span class="title">W601</span> - <span class="title">Use</span> "<span class="title">in</span>" <span class="title">rather</span> <span class="title">than</span> "<span class="title">has_key</span><span class="params">()</span>".</span></span><br><span class="line"><span class="class"><span class="title">W602</span> - <span class="title">Fix</span> <span class="title">deprecated</span> <span class="title">form</span> <span class="title">of</span> <span class="title">raising</span> <span class="title">exception</span>.</span></span><br><span class="line">W603 - Use "!=" instead of "&lt;&gt;"</span><br><span class="line">W604 - Use <span class="string">"repr()"</span> instead of backticks.</span><br><span class="line">W605 - Fix invalid escape sequence <span class="string">'x'</span>.</span><br><span class="line">W690 - Fix various deprecated code (via lib2to3).</span><br></pre></td></tr></table></figure><h5 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h5><p>原始test.py文件：<br><img src="/.com//old_autopep8.png" alt="这是一个乱糟糟的代码图~" style="zoom:70%;"></p><p>自动化修改后：<br><img src="/.com//new_autopep8.png" alt="这是一个整齐一点的代码图~" style="zoom:70%;"></p><p>当然，这个例子展示的只是一小部分，感觉没有显示出该库的便利之处——让混乱的代码变得整洁易读，读者不妨自行试一试~</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;这是一个可以让python代码自动规范化的开源库，写好的python看着比较混乱，可以使用该库直接改善代码布局，提升可读性。也可以在IDE内（比如PyCharm）中预先配置该库的插件。&lt;/p&gt;
&lt;h4 id=&quot;PEP8&quot;&gt;&lt;a href=&quot;#PEP8&quot; class=&quot;hea
      
    
    </summary>
    
    
      <category term="python模块" scheme="http://yoursite.com/categories/python%E6%A8%A1%E5%9D%97/"/>
    
    
      <category term="python" scheme="http://yoursite.com/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>algorithms 模块</title>
    <link href="http://yoursite.com/2020/04/18/algorithms%20%E6%A8%A1%E5%9D%97/"/>
    <id>http://yoursite.com/2020/04/18/algorithms%20%E6%A8%A1%E5%9D%97/</id>
    <published>2020-04-17T16:07:05.000Z</published>
    <updated>2020-04-17T16:14:45.045Z</updated>
    
    <content type="html"><![CDATA[<p>今天介绍一个有趣的第三方模块——algorithms，它提供用Python实现的一些算法和数据结构及其操作，不是简单的基本操作哦。比如各种排序算法。主要目的是用来<strong>学习</strong>哈，不是生产和工作。</p><p>若想知道模块中方法的源码可以在官网查阅，上面有详细的介绍，包括算法性能等：<br><a href="https://algorithms.readthedocs.io/en/latest/index.html" target="_blank" rel="noopener">https://algorithms.readthedocs.io/en/latest/index.html</a></p><p>模块安装方法：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pip install algorithms</span><br><span class="line">或 pip3 install algorithms  <span class="comment">#python3.x</span></span><br></pre></td></tr></table></figure><p>该模块包括如下<strong>子模块</strong>，可以看到涵盖了如下各种数据结构和相关算法：</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">arrays</span> <span class="string"></span></span><br><span class="line"><span class="attr">backtrack</span> <span class="string"></span></span><br><span class="line"><span class="attr">bit</span> <span class="string"></span></span><br><span class="line"><span class="attr">graph</span> <span class="string"></span></span><br><span class="line"><span class="attr">heap</span> <span class="string"></span></span><br><span class="line"><span class="attr">linkedlist</span></span><br><span class="line"><span class="attr">maths</span> <span class="string"></span></span><br><span class="line"><span class="attr">queues</span> <span class="string"></span></span><br><span class="line"><span class="attr">search</span> <span class="string"></span></span><br><span class="line"><span class="attr">sort</span></span><br><span class="line"><span class="attr">stack</span> <span class="string"></span></span><br><span class="line"><span class="attr">strings</span></span><br></pre></td></tr></table></figure><p>注意在使用某子模块中的方法时，需要<strong>直接的</strong>引入该子模块，不能仅导入algorithms模块或<code>from algorithms import *</code>，比如使用maths模块时，需要如下操作：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> algorithms <span class="keyword">import</span> maths</span><br></pre></td></tr></table></figure><p>这里以sort子模块具体举例：</p><h4 id="sort"><a href="#sort" class="headerlink" title="sort"></a>sort</h4><p>sort子模块的各种方法，大家看到名字也差不多知道是什么算法了吧，但是因为方法是返回输出后的结果，所以不能直接看出不同排序算法的区别，可以上官网查阅源码或者通过计时等方法测试比较一下哦。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">bogo_sort   <span class="comment">#猴子排序（恶搞的^_^）</span></span><br><span class="line">bubble_sort    <span class="comment">#冒泡排序</span></span><br><span class="line">bucket_sort    <span class="comment">#桶排序</span></span><br><span class="line">cocktail_shaker_sort    <span class="comment">#鸡尾酒排序、双向冒泡排序</span></span><br><span class="line">comb_sort     <span class="comment">#梳排序</span></span><br><span class="line">counting_sort   <span class="comment">#计数排序</span></span><br><span class="line">gnome_sort   <span class="comment">#地精排序，也叫stupid sort</span></span><br><span class="line">heap_sort    <span class="comment">#堆排序</span></span><br><span class="line">insertion_sort  <span class="comment">#插入排序</span></span><br><span class="line">merge_sort   <span class="comment">#归并排序</span></span><br><span class="line">quick_sort   <span class="comment">#快速排序</span></span><br><span class="line">radix_sort   <span class="comment">#基数排序</span></span><br><span class="line">selection_sort   <span class="comment">#选择排序 </span></span><br><span class="line">shell_sort   <span class="comment">#希尔排序 </span></span><br><span class="line">top_sort   <span class="comment">#拓扑排序</span></span><br><span class="line">wiggle_sort   <span class="comment">#摆动排序</span></span><br></pre></td></tr></table></figure><p><strong>举例：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> algorithms <span class="keyword">import</span> sort</span><br><span class="line">algorithms.sort.bubble_sort([<span class="number">1</span>,<span class="number">5</span>,<span class="number">3</span>,<span class="number">7</span>,<span class="number">3</span>,<span class="number">2</span>])</span><br><span class="line">algorithms.sort.shell_sort([<span class="number">1</span>,<span class="number">5</span>,<span class="number">3</span>,<span class="number">7</span>,<span class="number">3</span>,<span class="number">2</span>])</span><br><span class="line"><span class="comment">#都会返回升序的相同结果[1, 2, 3, 3, 5, 7]</span></span><br></pre></td></tr></table></figure><p>通过help可以查看复杂度：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">help(algorithms.sort.bogo_sort)</span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">bogo_sort(arr)</span></span><br><span class="line"><span class="string">    Bogo Sort</span></span><br><span class="line"><span class="string">    Best Case Complexity: O(n)</span></span><br><span class="line"><span class="string">    Worst Case Complexity: O(∞)</span></span><br><span class="line"><span class="string">    Average Case Complexity: O(n(n-1)!)</span></span><br><span class="line"><span class="string">'''</span><span class="string">'</span></span><br></pre></td></tr></table></figure><h4 id="其他模块"><a href="#其他模块" class="headerlink" title="其他模块"></a>其他模块</h4><p>鉴于各自模块包括方法较多，这里不一一展开介绍，感兴趣的话就动手试试吧~<br>具体的各模块包括方法如下表：</p><table><thead><tr><th>子模块名</th><th align="left">包含方法</th><th>解释</th></tr></thead><tbody><tr><td>arrays</td><td align="left">delete_nth     flatten     garage     josephus     longest_non_repeat                          max_ones_index     merge_intervals     missing_ranges     move_zeros     plus_one     rotate     summarize_ranges     three_sum     two_sum</td><td>关于数组的操作，比如删除第n个数、最长不重复子数组、两数和等</td></tr><tr><td>backtrack</td><td align="left">add_operators     anagram     array_sum_combinations     combination_sum     factor_combinations     find_words     generate_abbreviations     generate_parenthesis     letter_combination     palindrome_partitioning     pattern_match     permute     permute_unique     subsets     subsets_unique</td><td>回溯相关算法，比如查找回文子串等</td></tr><tr><td>bit</td><td align="left">add_bitwise_operator     bit_operation     bytes_int_conversion     count_flips_to_convert     count_ones     find_difference     find_missing_number     flip_bit_longest_sequence     has_alternative_bit     insert_bit     power_of_two     remove_bit     reverse_bits     single_number     single_number2     single_number3     subsets     swap_pair</td><td>位操作算法</td></tr><tr><td>graph</td><td align="left">Transitive_Closure_DFS     checkDiGraphStronglyConnected     clone_graph     cycle_detection     dijkstra     find_all_cliques     find_path     graph     markov_chain     minimum_spanning_tree     pathBetweenTwoVerticesInDiGraph     satisfiability     tarjan     traversal</td><td>图算法</td></tr><tr><td>linkedlist</td><td align="left">add_two_numbers     copy_random_pointer     delete_node     first_cyclic_node     intersection     is_cyclic     is_palindrome     is_sorted     kth_to_last     linkedlist     merge_two_list     partition     remove_duplicates     remove_range     reverse     rotate_list     swap_in_pairs</td><td>有序列表的操作、包括是否有序、是否回文、合并、删除重复值等</td></tr><tr><td>maths</td><td align="left">base_conversion     combination     extended_gcd     factorial     gcd     generate_strobogrammtic     is_strobogrammatic     next_bigger     next_perfect_square     nth_digit     prime_check     primes_sieve_of_eratosthenes     pythagoras     rabin_miller     rsa     sqrt_precision_factor     summing_digits</td><td>数学计算，包括最大公约数、下一个最大数等</td></tr><tr><td>queues</td><td align="left">max_sliding_window     moving_average     priority_queue     queue     reconstruct_queue     zigzagiterator</td><td>队列操作，包括移动窗口、优先队列等</td></tr><tr><td>search</td><td align="left">binary_search     find_min_rotate     first_occurance     jump_search     last_occurance     linear_search     search_insert     search_range     search_rotate     two_sum</td><td>包括查找的相关操作，比图：二分查找、首先出现、搜索范围、两数和等</td></tr><tr><td>sort</td><td align="left">bogo_sort     bubble_sort     bucket_sort     cocktail_shaker_sort     comb_sort     counting_sort     gnome_sort     heap_sort     insertion_sort     meeting_rooms     merge_sort     quick_sort     radix_sort     selection_sort     shell_sort     sort_colors     top_sort     wiggle_sort</td><td>见上文</td></tr><tr><td>stack</td><td align="left">is_consecutive     is_sorted     longest_abs_path     ordered_stack     remove_min     simplify_path     stack     stutter     switch_pairs     valid_parenthesis</td><td>栈的相关操作，包括单调栈等</td></tr><tr><td>strings</td><td align="left">add_binary     breaking_bad     decode_string     delete_reoccurring     domain_extractor     encode_decode     fizzbuzz     group_anagrams     int_to_roman     is_palindrome     is_rotated     license_number     make_sentence     merge_string_checker     multiply_strings     one_edit_distance     rabin_karp     reverse_string     reverse_vowel     reverse_words     roman_to_int     strip_url_params     validate_coordinates     word_squares</td><td>字符串的相关操作，包括转码、是否回文、倒置等</td></tr></tbody></table><p>从上述方法可以看到，很多方法其实就是我们平时遇到的算法题，并不是最基本的操作。再强调一下，该模块主要用途应该是学习！而不是直接调用，对于某方法可以上官网查阅源码。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;今天介绍一个有趣的第三方模块——algorithms，它提供用Python实现的一些算法和数据结构及其操作，不是简单的基本操作哦。比如各种排序算法。主要目的是用来&lt;strong&gt;学习&lt;/strong&gt;哈，不是生产和工作。&lt;/p&gt;
&lt;p&gt;若想知道模块中方法的源码可以在官网查阅
      
    
    </summary>
    
    
      <category term="python模块" scheme="http://yoursite.com/categories/python%E6%A8%A1%E5%9D%97/"/>
    
    
      <category term="python" scheme="http://yoursite.com/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>operator 模块</title>
    <link href="http://yoursite.com/2020/04/08/operator%20%E6%A8%A1%E5%9D%97/"/>
    <id>http://yoursite.com/2020/04/08/operator%20%E6%A8%A1%E5%9D%97/</id>
    <published>2020-04-08T14:41:45.000Z</published>
    <updated>2020-04-08T16:20:56.322Z</updated>
    
    <content type="html"><![CDATA[<p>该模块包括3个类和一些常见的运算操作等等。因为该模块是C语言编写的，所以其中方法的运算比直接用python编写要快。方法前后可以有双下滑线，和不带下划线等价，比如<code>add</code>和<code>__add__</code>。</p><p>operator中的类可以生成模板，自定义顺序访问指定索引的值、指定属性或指定方法。</p><h4 id="常用类"><a href="#常用类" class="headerlink" title="常用类"></a>常用类</h4><h5 id="itemgetter"><a href="#itemgetter" class="headerlink" title="itemgetter"></a>itemgetter</h5><p>生成一个可以从输入对象中获得固定<strong>索引</strong>的取值的可调用对象。比如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> operator</span><br><span class="line">a=operator.itemgetter(<span class="number">2</span>)   <span class="comment">#记录2作为索引</span></span><br><span class="line">a([<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>])   <span class="comment">#4</span></span><br><span class="line"></span><br><span class="line">b=operator.itemgetter(<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>)</span><br><span class="line">b((<span class="string">'a'</span>,<span class="string">'b'</span>,<span class="string">'c'</span>,<span class="string">'d'</span>,<span class="string">'e'</span>))   <span class="comment">#('d','c','b')</span></span><br></pre></td></tr></table></figure><p>通过该类可以指定索引和顺序，像是一个模板，将序列中对应索引的值按照模板的顺序输出。</p><h5 id="attrgetter"><a href="#attrgetter" class="headerlink" title="attrgetter"></a>attrgetter</h5><p>理解了itemgetter，那么attrgetter也就很容易理解了，它生成一个可以从输入对象中获得固定<strong>属性</strong>的可调用对象。</p><p>假如实例r有属性length：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> operator</span><br><span class="line">a=operator.attrgetter(<span class="string">'length'</span>)   <span class="comment">#记着加引号</span></span><br><span class="line">a(r)   <span class="comment">#r.length</span></span><br></pre></td></tr></table></figure><h5 id="methodcaller"><a href="#methodcaller" class="headerlink" title="methodcaller"></a>methodcaller</h5><p>生成一个可以从输入对象中获得固定<strong>方法</strong>的可调用对象。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> operator</span><br><span class="line">a=<span class="string">'123'</span></span><br><span class="line">b=operator.methodcaller(<span class="string">'isalpha'</span>)  <span class="comment">#记着加引号</span></span><br><span class="line">b(a)   <span class="comment">#False  等价于a.isalpha()   </span></span><br><span class="line"></span><br><span class="line">a=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">3</span>]</span><br><span class="line">b=operator.methodcaller(<span class="string">'count'</span><span class="number">3</span>)   <span class="comment">#3是count()的输入参数</span></span><br><span class="line">b(a)  <span class="comment">#2   等价于a.count(3)</span></span><br></pre></td></tr></table></figure><p>当需要访问很多不同对象的相同方法或属性，可以借助attrgetter和methodcaller方法生成一个模板，然后调用它。</p><h4 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h4><p>因为operator大部分是常见运算，所以我不用往常介绍+举例的方式了，直接列表对比供各位查阅：</p><h5 id="数学计算"><a href="#数学计算" class="headerlink" title="数学计算"></a>数学计算</h5><table><thead><tr><th>operator中的方法</th><th>意义</th></tr></thead><tbody><tr><td>abs</td><td>绝对值</td></tr><tr><td>add(a, b)</td><td>a+b</td></tr><tr><td>sub(a, b)</td><td>a-b</td></tr><tr><td>mul(a, b)</td><td>a*b</td></tr><tr><td>truediv(a, b)</td><td>a/b</td></tr><tr><td>floordiv(a, b)</td><td>a//b   （取商）</td></tr><tr><td>mod(a, b)</td><td>a%b   （取模）</td></tr><tr><td>pow(a, b)</td><td>a**b   （次方）</td></tr><tr><td>neg(a)</td><td>-a</td></tr><tr><td>pos(a)</td><td>+a</td></tr><tr><td>matmul(a, b)</td><td>a@b    （矩阵乘法）</td></tr></tbody></table><h5 id="比较、判断运算"><a href="#比较、判断运算" class="headerlink" title="比较、判断运算"></a>比较、判断运算</h5><table><thead><tr><th>operator中的方法</th><th>意义</th></tr></thead><tbody><tr><td>eq(a, b)</td><td>a==b</td></tr><tr><td>ne(a, b)</td><td>a!=b</td></tr><tr><td>ge(a, b)</td><td>a&gt;=b</td></tr><tr><td>gt(a, b)</td><td>a&gt;b</td></tr><tr><td>le(a, b)</td><td>a&lt;=b</td></tr><tr><td>lt(a, b)</td><td>a&lt;b</td></tr><tr><td>not_(a)</td><td>not a</td></tr><tr><td>truth(a)</td><td>a==True  （判断a是否True）</td></tr><tr><td>is_(a, b)</td><td>a is b</td></tr><tr><td>is_not(a, b)</td><td>a is not b</td></tr></tbody></table><h5 id="位运算"><a href="#位运算" class="headerlink" title="位运算"></a>位运算</h5><table><thead><tr><th>operator中的方法</th><th>意义</th></tr></thead><tbody><tr><td>and_(a, b)</td><td>&amp;</td></tr><tr><td>or_(a, b)</td><td>|</td></tr><tr><td>xor(a, b)</td><td>^   （异或）</td></tr><tr><td>inv(a),invert(a)</td><td>~   （各位取反）</td></tr><tr><td>lshift(a, b)</td><td>&lt;&lt;</td></tr><tr><td>rshift(a, b)</td><td>&gt;&gt;</td></tr></tbody></table><h5 id="赋值运算"><a href="#赋值运算" class="headerlink" title="赋值运算"></a>赋值运算</h5><table><thead><tr><th>operator中的方法</th><th>意义</th></tr></thead><tbody><tr><td>a=iadd(a, b)</td><td>a += b</td></tr><tr><td>a=isub(a, b)</td><td>a -= b</td></tr><tr><td>a = imul(a, b)</td><td>a *= b</td></tr><tr><td>a = itruediv(a, b)</td><td>a /= b</td></tr><tr><td>a = ifloordiv(a, b)</td><td>a //= b</td></tr><tr><td>a = imod(a, b)</td><td>a %= b</td></tr><tr><td>a = ipow(a, b)</td><td>a **= b</td></tr><tr><td>a = irshift(a, b)</td><td>a &gt;&gt;= b</td></tr><tr><td>a = ilshift(a, b)</td><td>a &lt;&lt;= b</td></tr><tr><td>a = ior(a, b)</td><td>a |= b</td></tr><tr><td>a = iand(a, b)</td><td>a &amp;= b</td></tr><tr><td>a = ixor(a, b)</td><td>a ^= b</td></tr><tr><td>a = imatmul(a, b)</td><td>a @= b</td></tr><tr><td>a = iconcat(a, b)</td><td>a += b (a, b是序列)</td></tr></tbody></table><h5 id="序列操作"><a href="#序列操作" class="headerlink" title="序列操作"></a>序列操作</h5><table><thead><tr><th>operator中的方法</th><th>意义</th></tr></thead><tbody><tr><td>concat(a, b)</td><td>拼接两个序列</td></tr><tr><td>contains(a, b)</td><td>b in a</td></tr><tr><td>countOf(a, b)</td><td>a中b的次数</td></tr><tr><td>index(a)</td><td>a的索引</td></tr><tr><td>indexOf(a, b)</td><td>a中b的第一个索引</td></tr><tr><td>delitem(a, b)</td><td>del a[b]  (删除a[b])</td></tr><tr><td>getitem(a, b)</td><td>a[b]</td></tr><tr><td>setitem(a, b, c)</td><td>a[b] = c</td></tr><tr><td>length_hint(obj, default=0)</td><td>len(obj)    （求序列长度）</td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;该模块包括3个类和一些常见的运算操作等等。因为该模块是C语言编写的，所以其中方法的运算比直接用python编写要快。方法前后可以有双下滑线，和不带下划线等价，比如&lt;code&gt;add&lt;/code&gt;和&lt;code&gt;__add__&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;operator中的
      
    
    </summary>
    
    
      <category term="python模块" scheme="http://yoursite.com/categories/python%E6%A8%A1%E5%9D%97/"/>
    
    
      <category term="python" scheme="http://yoursite.com/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>queue 模块</title>
    <link href="http://yoursite.com/2020/03/27/queue%20%E6%A8%A1%E5%9D%97/"/>
    <id>http://yoursite.com/2020/03/27/queue%20%E6%A8%A1%E5%9D%97/</id>
    <published>2020-03-27T12:11:25.000Z</published>
    <updated>2020-03-28T12:48:54.423Z</updated>
    
    <content type="html"><![CDATA[<p>queue模块提供了队列这种数据结构，不必费时间自己去构建这类数据结构，比较方便。</p><p>虽然我们可以基于python中的list数据结构，使用pop(0)和append方法实现普通的队列。但是queue模块中提供了更丰富队列的API，该模块主要提供三种队列：Queue、LifoQueue、PriorityQueue。Queue就是前面说的普通队列，先入先出(FIFO)，有最大容量；LifoQueue类似栈，后入先出(LIFO)；PriorityQueue是优先队列，也是我认为这个模块最重要的类。</p><p>另外，其实queue模块还有一种类deque，即双向队列，方法和collections模块的deque类相同，本文不赘述。</p><p>下面先简要介绍一下优先队列这种数据结构：</p><h4 id="优先队列"><a href="#优先队列" class="headerlink" title="优先队列"></a>优先队列</h4><p>我们知道队列是先进去的元素可以先出来（FIFO），出队的次序完全取决于进队时间的早晚，队伍内部不改变数据的相对顺序。但是有时候我们希望维护这样一种数据结构，虽然进入数据有先后，但是每次取出的元素都是最大或最小的，即出队的数据是经过排序的，是有优先级的。这就是优先队列。python的queue模块中，优先队列中优先级约小越先出队。</p><p>优先队列通常都是通过堆来实现的，我另外一篇博文介绍了python的heapq模块，可以实现堆这种数据结构，提到了它的一种应用就是实现优先队列。queue模块的优先队列和heapq模块实现的优先队列的区别是：heapq模块实现最小堆，输入元素是包含数字的列表，通过数字大小排列优先级；queue模块的PriorityQueue，入队元素是tuple，优先级数字在元组中输入，数据可以是任意类型，具体介绍见下文。</p><h4 id="queue模块"><a href="#queue模块" class="headerlink" title="queue模块"></a>queue模块</h4><p> 在python2中模块名是Queue。</p><h5 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h5><p>因为queue模块中三种类的方法基本相同，所以下面仅以Queue类为例进行介绍。PriorityQueue的put方法有点差异。</p><p><em>注意：</em>这里Queue是类的名称，不是模块名。</p><p>为了方便介绍后面的方法，生成了一个队列q。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">q=queue.Queue(maxsize=<span class="number">0</span>)</span><br><span class="line"><span class="comment">#初始化一个队列，maxsize表示最大容量，若小于等于0,表示容量无限。默认为0。</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">q.empty()</span><br><span class="line"><span class="comment">#若队列空，返回True，否则False</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">q.full()</span><br><span class="line"><span class="comment">#若队列满，返回True，否则False</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">q.qsize()</span><br><span class="line"><span class="comment">#返回队列实际长度，即元素数量</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">q.put(item, block=<span class="literal">True</span>, timeout=<span class="literal">None</span>)</span><br><span class="line"><span class="comment">#元素入队，可以不同类型</span></span><br><span class="line">q.put((priority number,data)，block=<span class="literal">True</span>, timeout=<span class="literal">None</span>)</span><br><span class="line"><span class="comment">#对于PriorityQueue，入队元素必须是tuple类型，其中priority number表示优先级，越小越优先，data是数据</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">q.get(block=<span class="literal">True</span>, timeout=<span class="literal">None</span>)</span><br><span class="line"><span class="comment">#元素出队，对不同类的队列，出队方式不同</span></span><br></pre></td></tr></table></figure><p><em>注意：get和put方法中的block默认为True，timeout默认为None。block为True表示，若发生阻塞（空队列时get，或满队列时put），等待timeout秒再报错，timeout默认None表示阻塞时一直等待。block为False表示，发生阻塞立刻抛出异常，停止程序。</em></p><h5 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h5><h6 id="Queue"><a href="#Queue" class="headerlink" title="Queue"></a>Queue</h6><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> queue</span><br><span class="line">q=queue.Queue(<span class="number">5</span>)</span><br><span class="line">q.put(<span class="string">'a'</span>)</span><br><span class="line">q.put([<span class="number">1</span>,<span class="number">2</span>])</span><br><span class="line">q.qsize()   <span class="comment">#2</span></span><br><span class="line">q.get()   <span class="comment">#'a'</span></span><br></pre></td></tr></table></figure><h6 id="PriorityQueue"><a href="#PriorityQueue" class="headerlink" title="PriorityQueue"></a>PriorityQueue</h6><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> queue</span><br><span class="line">p=queue.PriorityQueue()</span><br><span class="line">p.put((<span class="number">2</span>,<span class="string">'a'</span>))</span><br><span class="line">p.put((<span class="number">1</span>,[<span class="number">1</span>,<span class="number">2</span>]))</span><br><span class="line">p.put((<span class="number">3</span>,<span class="number">1</span>))</span><br><span class="line">p.get()   <span class="comment">#(1, [1, 2])</span></span><br></pre></td></tr></table></figure><h6 id="LifoQueue"><a href="#LifoQueue" class="headerlink" title="LifoQueue"></a>LifoQueue</h6><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> queue</span><br><span class="line">s=queue.LifoQueue()</span><br><span class="line">s.put(&#123;<span class="number">1</span>,<span class="number">2</span>&#125;)</span><br><span class="line">s.put(<span class="number">1</span>)</span><br><span class="line">s.put(<span class="string">'abc'</span>)</span><br><span class="line">s.qsize()   <span class="comment">#3</span></span><br><span class="line">s.get()   <span class="comment">#'abc'</span></span><br><span class="line">s.qsize()   <span class="comment">#2</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;queue模块提供了队列这种数据结构，不必费时间自己去构建这类数据结构，比较方便。&lt;/p&gt;
&lt;p&gt;虽然我们可以基于python中的list数据结构，使用pop(0)和append方法实现普通的队列。但是queue模块中提供了更丰富队列的API，该模块主要提供三种队列：Que
      
    
    </summary>
    
    
      <category term="python模块" scheme="http://yoursite.com/categories/python%E6%A8%A1%E5%9D%97/"/>
    
    
      <category term="python" scheme="http://yoursite.com/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>heapq 模块</title>
    <link href="http://yoursite.com/2020/03/17/heapq%20%E6%A8%A1%E5%9D%97/"/>
    <id>http://yoursite.com/2020/03/17/heapq%20%E6%A8%A1%E5%9D%97/</id>
    <published>2020-03-17T08:45:45.000Z</published>
    <updated>2020-05-30T15:58:06.244Z</updated>
    
    <content type="html"><![CDATA[<p>该模块可以实现堆，是python自带模块。当需要使用堆这种数据结构时，可以不必自己编写，直接调用该模块的api，比较方便。</p><p>下面先简单介绍一下堆。</p><h4 id="堆（heap）"><a href="#堆（heap）" class="headerlink" title="堆（heap）"></a>堆（heap）</h4><p>堆是一种用数组实现的二叉树，具有以下特点：</p><ul><li>堆中每个节点的值总是不大于或不小于其父节点的值</li><li>堆是一棵完全二叉树</li></ul><p>根节点最大的堆叫最大堆，根节点最小的堆叫最小堆。</p><p>因为堆是完全二叉树，所以其实现方式不像树使用链式结构从父节点用指针指向子节点。在数组中，堆中某节点的左子节点是该节点索引乘2，右子节点是该节点索引乘2再加1，如下图是一个最大堆：</p><img src="/.com//heap.png" alt="这是一个最大堆的结构图~" style="zoom:63%;"><p>上图红字是数组中的索引，堆的索引通常从1开始。可见左子节点索引是父节点的2倍，右子节点是父节点索引的2倍再加1。</p><p><strong>堆的常见应用</strong>：</p><ul><li>实现优先队列，可以很容易找出最大值或最小值，并进行删除操作。</li><li>堆排序</li></ul><p>当heap中发生元素变动时，比如添加一个数值，该数可能会对heap结构产生影响，有的节点要改变位置。heapq模块提供方法可以将一个列表转换为堆，可以直接增、删节点，节点根据大小自动变换位置。</p><h4 id="heapq模块中的堆"><a href="#heapq模块中的堆" class="headerlink" title="heapq模块中的堆"></a>heapq模块中的堆</h4><ul><li>索引从0开始。 这使得节点的索引与其子节点的索引之间的关系不太明显，但由于Python中对象从0开始索引，因此更适合。</li><li>最小堆，即：heap[0]是最小项，heappop方法弹出最小项。</li></ul><h5 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">heapq.heapify(x)</span><br><span class="line"><span class="comment">#将一个list原地转换为一个heap，即x按照heap结构排序。时间复杂度：O(len(x))</span></span><br></pre></td></tr></table></figure><p><em>注：</em>heap在python中类型还是list，一个空的list可以作为heap的初始化。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">heapq.heappop(x)      -&gt;   x[0]</span><br><span class="line"><span class="comment">#从一个heap（list）中弹出顶部元素（最小值）</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">heapq.heappush(x,item)</span><br><span class="line"><span class="comment">#向一个heap中添加元素，自动排序</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">heapq.heapreplace(x,item)   -&gt;   x[0]</span><br><span class="line"><span class="comment">#弹出并返回顶部元素，并添加新元素，排序。heap的大小不变。</span></span><br></pre></td></tr></table></figure><h5 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h5><p>为了方便演示，初始化一个列表x，下述方法按顺序进行。</p><h6 id="heapify"><a href="#heapify" class="headerlink" title="heapify"></a>heapify</h6><p>将输入的list原地转换为heap，本质是进行了排序的操作。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> heapq</span><br><span class="line">x=[<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">1</span>,<span class="number">7</span>,<span class="number">2</span>,<span class="number">8</span>]</span><br><span class="line">heapq.heapify(x)</span><br><span class="line">x    <span class="comment"># [1, 4, 2, 5, 7, 6, 8]   1是顶部元素；4、2处于第二层；5、7、6、8处于第三层</span></span><br></pre></td></tr></table></figure><h6 id="heappop"><a href="#heappop" class="headerlink" title="heappop"></a>heappop</h6><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> heapq</span><br><span class="line">heapq.heappop(x)      <span class="comment">#  1</span></span><br><span class="line">x    <span class="comment"># [2, 4, 6, 5, 7, 8]      将1弹出后，顶部元素变为2</span></span><br></pre></td></tr></table></figure><h6 id="heappush"><a href="#heappush" class="headerlink" title="heappush"></a>heappush</h6><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> heapq</span><br><span class="line">heapq.heappush(x,<span class="number">3</span>)</span><br><span class="line">x    <span class="comment"># [2, 4, 3, 5, 7, 8, 6]   3进入堆中相应位置，对原结构也产生了影响</span></span><br></pre></td></tr></table></figure><h6 id="heapreplace"><a href="#heapreplace" class="headerlink" title="heapreplace"></a>heapreplace</h6><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> heapq</span><br><span class="line">heapq.heapreplace(x,<span class="number">1</span>) <span class="comment">#  2   将顶部元素弹出并返回</span></span><br><span class="line">x    <span class="comment"># [1, 4, 3, 5, 7, 8, 6]  将1加入堆中，重新排序</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;该模块可以实现堆，是python自带模块。当需要使用堆这种数据结构时，可以不必自己编写，直接调用该模块的api，比较方便。&lt;/p&gt;
&lt;p&gt;下面先简单介绍一下堆。&lt;/p&gt;
&lt;h4 id=&quot;堆（heap）&quot;&gt;&lt;a href=&quot;#堆（heap）&quot; class=&quot;headerlin
      
    
    </summary>
    
    
      <category term="python模块" scheme="http://yoursite.com/categories/python%E6%A8%A1%E5%9D%97/"/>
    
    
      <category term="python" scheme="http://yoursite.com/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>math 模块</title>
    <link href="http://yoursite.com/2020/03/15/math%20%E6%A8%A1%E5%9D%97/"/>
    <id>http://yoursite.com/2020/03/15/math%20%E6%A8%A1%E5%9D%97/</id>
    <published>2020-03-15T14:04:11.000Z</published>
    <updated>2020-03-15T15:36:15.119Z</updated>
    
    <content type="html"><![CDATA[<p>该模块提供了由C语言标准定义的数学函数。</p><p>还有一个模块叫cmath，其中定义的方法和属性与math模块基本相同，只是cmath适用于复数（complex）。</p><h4 id="常用属性"><a href="#常用属性" class="headerlink" title="常用属性"></a>常用属性</h4><table><thead><tr><th>名称</th><th>值</th></tr></thead><tbody><tr><td>math.pi</td><td>3.141592653589793</td></tr><tr><td>math.e</td><td>2.718281828459045</td></tr><tr><td>math.inf</td><td>inf</td></tr><tr><td>math.nan</td><td>nan</td></tr><tr><td>math.tau</td><td>6.283185307179586</td></tr></tbody></table><p><em>注：</em>对于无穷数除了用math.inf，还可以用float(‘inf’)表示正无穷；-float(‘inf’)或float(‘-inf’)表示负无穷。</p><h4 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h4><h5 id="三角函数"><a href="#三角函数" class="headerlink" title="三角函数"></a>三角函数</h5><p>三角函数返回结果为弧度值。</p><table><thead><tr><th>名称</th><th>含义</th></tr></thead><tbody><tr><td>math.acos(x)</td><td>反余弦</td></tr><tr><td>math.acosh(x)</td><td>反双曲余弦</td></tr><tr><td>math.asin(x)</td><td>反正弦</td></tr><tr><td>math.asinh(x)</td><td>反双曲余弦</td></tr><tr><td>math.atan(x)</td><td>反正切</td></tr><tr><td>math.atan2(x,y)</td><td>x/y的反正切，与atan(y/x)不同，x和y的符号均被考虑</td></tr><tr><td>math.atanh(x)</td><td>反双曲正切</td></tr><tr><td>math.cos(x)</td><td>余弦</td></tr><tr><td>math.cosh(x)</td><td>双曲余弦</td></tr><tr><td>math.sin(x)</td><td>正弦</td></tr><tr><td>math.sinh(x)</td><td>双曲正弦</td></tr><tr><td>math.tan(x)</td><td>正切</td></tr><tr><td>math.tanh(x)</td><td>双曲正切</td></tr><tr><td>math.degrees(x)</td><td>将弧度值转为角度值</td></tr><tr><td>math.radians(x)</td><td>将角度值转为弧度值</td></tr></tbody></table><h5 id="取整、取小数的函数"><a href="#取整、取小数的函数" class="headerlink" title="取整、取小数的函数"></a>取整、取小数的函数</h5><table><thead><tr><th>名称</th><th>含义</th></tr></thead><tbody><tr><td>math.ceil(x)</td><td>返回不小于x的整数，即：向上取整</td></tr><tr><td>math.floor(x)</td><td>返回不大于x的整数，即：向下取整</td></tr><tr><td>math.trunc(x)</td><td>返回整数部分，和int等效</td></tr><tr><td>math.modf(x)</td><td>返回小数和整数部分，都为浮点数，都带x的符号</td></tr></tbody></table><h5 id="指数、对数函数"><a href="#指数、对数函数" class="headerlink" title="指数、对数函数"></a>指数、对数函数</h5><table><thead><tr><th>名称</th><th>含义</th></tr></thead><tbody><tr><td>math.exp(x)</td><td>以e为底的指数</td></tr><tr><td>math.expm1(x)</td><td>以e为底的指数后减1，对x较小的情况进行精确计算</td></tr><tr><td>math.log(x[, base])</td><td>返回底为base的对数，默认为e</td></tr><tr><td>math.log10(x)</td><td>底为10的对数</td></tr><tr><td>math.log2(x)</td><td>底为2的对数</td></tr><tr><td>math.log1p(x)</td><td>返回1+x的自然对数（底为e），对x接近零的结果进行精确计算</td></tr></tbody></table><h5 id="判断函数"><a href="#判断函数" class="headerlink" title="判断函数"></a>判断函数</h5><table><thead><tr><th>名称</th><th>含义</th></tr></thead><tbody><tr><td>math.isfinite(x)</td><td>判断x是否有限（非inf，非nan）</td></tr><tr><td>math.isinf(x)</td><td>判断x是否是无穷</td></tr><tr><td>math.isnan(x)</td><td>判断x是否是NaN（Not a Number）</td></tr><tr><td>math. isclose(a,b, rel_tol=1e-09, abs_tol=0.0)</td><td>判断两个浮点数值是否接近。rel_tol表示最大相对差异，abs_tol表示最大绝对差异。<em>注：</em>nan和谁都不接近；inf只和自己接近</td></tr></tbody></table><h5 id="其他函数"><a href="#其他函数" class="headerlink" title="其他函数"></a>其他函数</h5><table><thead><tr><th>名称</th><th>含义</th></tr></thead><tbody><tr><td>math.fabs(x)</td><td>绝对值</td></tr><tr><td>math.gcd(x,y)</td><td>x和y的最大公约数</td></tr><tr><td>math.sqrt(x)</td><td>平方根</td></tr><tr><td>math.factorial(x)</td><td>x的阶乘，若x负数或小数，则报错</td></tr><tr><td>math.hypot(x,y)</td><td>欧氏距离，即：<code>sqrt(x*x + y*y)</code></td></tr><tr><td>math.pow(x,y)</td><td>x的y次方</td></tr><tr><td>math.fmod(x,y)</td><td>x对y取余，根据C平台计算，结果可能与x%y不同</td></tr><tr><td>math.fsum(iterable)</td><td>返回浮点数之和的精确值</td></tr><tr><td>math.ldexp(x,i)</td><td><code>x * (2**i)</code></td></tr><tr><td>math.frexp(x)</td><td>ldexp的反函数，返回x的尾数和指数</td></tr><tr><td>math.gamma(x)</td><td>x处的Gamma函数</td></tr><tr><td>math.lgamma(x)</td><td>x处Gamma函数的绝对值的自然对数</td></tr><tr><td>math.erf(x)</td><td>x处的误差函数</td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;该模块提供了由C语言标准定义的数学函数。&lt;/p&gt;
&lt;p&gt;还有一个模块叫cmath，其中定义的方法和属性与math模块基本相同，只是cmath适用于复数（complex）。&lt;/p&gt;
&lt;h4 id=&quot;常用属性&quot;&gt;&lt;a href=&quot;#常用属性&quot; class=&quot;headerlink
      
    
    </summary>
    
    
      <category term="python模块" scheme="http://yoursite.com/categories/python%E6%A8%A1%E5%9D%97/"/>
    
    
      <category term="python" scheme="http://yoursite.com/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>profile、line_profiler和memory_profiler 模块</title>
    <link href="http://yoursite.com/2020/03/03/profile%20%20line_profiler%E5%92%8Cmemory_profiler%E6%A8%A1%E5%9D%97/"/>
    <id>http://yoursite.com/2020/03/03/profile%20%20line_profiler%E5%92%8Cmemory_profiler%E6%A8%A1%E5%9D%97/</id>
    <published>2020-03-03T10:22:11.000Z</published>
    <updated>2020-03-03T11:02:02.320Z</updated>
    
    <content type="html"><![CDATA[<p>profile和line_profiler两个模块都是性能分析工具。有时候需要找到代码中运行速度较慢处或瓶颈，可以通过这两模块实现，而不再使用time计时。</p><p>line_profiler模块可以记录每行代码的运行时间和耗时百分比。</p><p>memory_profiler模块用来监控进程，记录每行代码的内存使用状况。</p><p>profile是python自带性能分析模块。line_profiler和memory_profiler模块都需要自行安装。</p><h4 id="profile"><a href="#profile" class="headerlink" title="profile"></a>profile</h4><h5 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">profile.run(statement, filename=<span class="literal">None</span>, sort=<span class="number">-1</span>)</span><br><span class="line"><span class="comment">#filename用来设置输出文件，默认直接打印</span></span><br></pre></td></tr></table></figure><p>输出结果的各项含义：</p><table><thead><tr><th>名称</th><th>含义</th></tr></thead><tbody><tr><td>ncalls</td><td>函数被调用次数</td></tr><tr><td>tottime</td><td>函数（除去子函数）总运行时间</td></tr><tr><td>percall</td><td>平均时间，等于tottime/ncalls</td></tr><tr><td>cumtime</td><td>函数（包括子函数）总运行时间</td></tr><tr><td>percall</td><td>平均时间，等于cumtime/ncalls</td></tr><tr><td>filename</td><td>文件：行号（函数）</td></tr></tbody></table><p>基于上述信息可以分析代码性能，通过filename可以知道哪个文件第几行的啥函数运行了多少次，运行时间多少。</p><h5 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> profile</span><br><span class="line">a=[[<span class="number">1</span>,<span class="number">5</span>],[<span class="number">2</span>,<span class="number">3</span>],[<span class="number">6</span>,<span class="number">6</span>],[<span class="number">0</span>,<span class="number">0</span>]]</span><br><span class="line">profile.run(<span class="string">'sorted(a,key=lambda x:x[1])'</span>)</span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string"> 9 function calls in 0.000 seconds</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">   Ordered by: standard name</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">   ncalls  tottime  percall  cumtime  percall filename:lineno(function)</span></span><br><span class="line"><span class="string">        1    0.000    0.000    0.000    0.000 :0(exec)</span></span><br><span class="line"><span class="string">        1    0.000    0.000    0.000    0.000 :0(setprofile)</span></span><br><span class="line"><span class="string">        1    0.000    0.000    0.000    0.000 :0(sorted)</span></span><br><span class="line"><span class="string">        4    0.000    0.000    0.000    0.000 &lt;string&gt;:1(&lt;lambda&gt;)</span></span><br><span class="line"><span class="string">        1    0.000    0.000    0.000    0.000 &lt;string&gt;:1(&lt;module&gt;)</span></span><br><span class="line"><span class="string">        0    0.000             0.000          profile:0(profiler)</span></span><br><span class="line"><span class="string">        1    0.000    0.000    0.000    0.000 profile:0(sorted(a,key=lambda x:x[1]))</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="comment">#通过上述结果，可以看出string中第1行的lambda函数运行了四次</span></span><br></pre></td></tr></table></figure><p>也可以先生成Profiler实例对象，再run：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">p=profile.Profile()</span><br><span class="line">p.run(<span class="string">'sum'</span>)      <span class="comment">#&lt;profile.Profile at 0x7f01ca552c18&gt;</span></span><br><span class="line">p.print_stats()   <span class="comment">#将性能打印出来</span></span><br></pre></td></tr></table></figure><h4 id="line-profiler"><a href="#line-profiler" class="headerlink" title="line_profiler"></a>line_profiler</h4><h5 id="常用方法-1"><a href="#常用方法-1" class="headerlink" title="常用方法"></a>常用方法</h5><p>该模块常通过装饰器来使用。在安装好该模块后，编写需要测试的python程序，并在<strong>需要测试的函数</strong>上方加入<code>@profile</code>，保存为*.py文件。在命令行使用<code>kernprof -l -v *.py</code>，在输出打印出程序结果之后会打印性能分析。</p><p>输出结果的含义：</p><table><thead><tr><th>名称</th><th>意义</th></tr></thead><tbody><tr><td>Timer unit</td><td>计时器单位，微秒</td></tr><tr><td>Total time</td><td>测试代码总运行时间</td></tr><tr><td>File</td><td>测试代码文件名</td></tr><tr><td>Hits</td><td>每行代码运行次数</td></tr><tr><td>Time</td><td>每行代码运行时间</td></tr><tr><td>Per Hit</td><td>每行代码运行一次的时间</td></tr><tr><td>% Time</td><td>每行代码运行时间的百分比</td></tr><tr><td>Line Contents</td><td>每行代码</td></tr></tbody></table><h5 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h5><p>将下列代码保存为test.py，不需要导入line_profiler模块。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@profile</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">compute</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">100</span>):</span><br><span class="line">        print(i**<span class="number">3</span>)</span><br><span class="line"><span class="keyword">if</span> __name__==<span class="string">'__main__'</span>:</span><br><span class="line">    compute()</span><br></pre></td></tr></table></figure><p>在命令行运行<code>kernprof -l -v test.py</code>，注意如果test.py不在命令行当前文件夹，需要些写上路径。输出为：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">Wrote profile results to test.py.lprof</span></span><br><span class="line"><span class="string">Timer unit: 1e-06 s</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Total time: 0.012405 s</span></span><br><span class="line"><span class="string">File: test.py</span></span><br><span class="line"><span class="string">Function: compute at line 1</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Line #      Hits         Time  Per Hit   % Time  Line Contents</span></span><br><span class="line"><span class="string">==============================================================</span></span><br><span class="line"><span class="string">     1                                           @profile</span></span><br><span class="line"><span class="string">     2                                           def compute():</span></span><br><span class="line"><span class="string">     3       101         74.0      0.7      0.6      for i in range(100):</span></span><br><span class="line"><span class="string">     4       100      12331.0    123.3     99.4          print(i**3)</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="comment">#可以分析代码性能，比如 print(i**3)共执行了100次，平均每次运行时间123.3微秒。</span></span><br></pre></td></tr></table></figure><h4 id="memory-profiler"><a href="#memory-profiler" class="headerlink" title="memory_profiler"></a>memory_profiler</h4><h5 id="常用方法-2"><a href="#常用方法-2" class="headerlink" title="常用方法"></a>常用方法</h5><p>使用方法同line_profiler模块，借助装饰器调用。在需要分析的函数上方加<code>@profile</code>。在命令行使用<code>python -m memory_profiler *.py</code>运行代码。<br>输出结果中：<br>Mem usage：内存使用情况<br>Increment：每行代码运行后内存增减情况</p><p>还有一种调用该模块的方式，在测试代码中导入memory_profiler模块的profile方法，如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> memory_profiler <span class="keyword">import</span> profile</span><br></pre></td></tr></table></figure><p>其余编写方法同上，装饰器的参数如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@profile(func=None, stream=None, precision=1, backend='psutil')</span></span><br><span class="line"><span class="comment">#stream表示将分析结果输出的文件，默认为命令行；precision表示分析结果中数字小数点保留位数。</span></span><br></pre></td></tr></table></figure><p>这种方法在命令行只需运行<code>python *.py</code>即可，若不需要测试性能，可直接将装饰器注释掉。</p><h5 id="示例-2"><a href="#示例-2" class="headerlink" title="示例"></a>示例</h5><p>将下列代码保存为test.py，不需要导入line_profiler模块。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> memory_profiler <span class="keyword">import</span> profile</span><br><span class="line"><span class="meta">@profile(precision=2)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">compute</span><span class="params">()</span>:</span></span><br><span class="line">    a=[]</span><br><span class="line">    b=<span class="number">3.4</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>):</span><br><span class="line">        a.append(i)</span><br><span class="line">    <span class="keyword">del</span> b</span><br><span class="line"><span class="keyword">if</span> __name__==<span class="string">'__main__'</span>:</span><br><span class="line">    compute()</span><br></pre></td></tr></table></figure><p>在命令行运行<code>python test.py</code>，注意路径。若代码中没有导入memory_profiler模块的profile方法，则应该运行<code>python -m memory_profiler test.py</code>。输出为：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">Line #    Mem usage    Increment   Line Contents</span></span><br><span class="line"><span class="string">================================================</span></span><br><span class="line"><span class="string">     2    39.08 MiB    39.08 MiB   @profile(precision=2)</span></span><br><span class="line"><span class="string">     3                             def compute():</span></span><br><span class="line"><span class="string">     4    39.08 MiB     0.00 MiB       a=[10]*100</span></span><br><span class="line"><span class="string">     5    39.08 MiB     0.00 MiB       b=3.4</span></span><br><span class="line"><span class="string">     6    39.08 MiB     0.00 MiB       for i in range(10):</span></span><br><span class="line"><span class="string">     7    39.08 MiB     0.00 MiB           a.append(i)</span></span><br><span class="line"><span class="string">     8    39.08 MiB     0.00 MiB       del b</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="comment">#输出分析结果的数字保留了2位小数</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;profile和line_profiler两个模块都是性能分析工具。有时候需要找到代码中运行速度较慢处或瓶颈，可以通过这两模块实现，而不再使用time计时。&lt;/p&gt;
&lt;p&gt;line_profiler模块可以记录每行代码的运行时间和耗时百分比。&lt;/p&gt;
&lt;p&gt;memory_p
      
    
    </summary>
    
    
      <category term="python模块" scheme="http://yoursite.com/categories/python%E6%A8%A1%E5%9D%97/"/>
    
    
      <category term="python" scheme="http://yoursite.com/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>jieba 模块</title>
    <link href="http://yoursite.com/2020/02/25/jieba%20%E6%A8%A1%E5%9D%97/"/>
    <id>http://yoursite.com/2020/02/25/jieba%20%E6%A8%A1%E5%9D%97/</id>
    <published>2020-02-24T16:04:11.000Z</published>
    <updated>2020-02-25T16:05:27.978Z</updated>
    
    <content type="html"><![CDATA[<p>用于中文词语切分的库。切分模式有以下三种：</p><p>全模式：返回句子中所有可能的词语，可重复使用字。</p><p>精确模式：将句子精确划分成多个词语，字不能复用。</p><p>搜索引擎模式：在精确模式的基础上近一步划分长词</p><h4 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h4><p>jieba模块中有Tokenizer类型，很多模块方法也是Tokenizer实例的属性。以下仅介绍常用方法（属性），实现切分中文字符串的功能。</p><p>jieba还有其他有用的函数，比如load_userdict可以载入个人字典，提升分词结果的准确性。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">jieba.cut(sentence, cut_all=<span class="literal">False</span>, HMM=<span class="literal">True</span>, use_paddle=<span class="literal">False</span>)</span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">返回Tokenizer类型，参数：</span></span><br><span class="line"><span class="string">sentence:输入要切分的句子，str类型</span></span><br><span class="line"><span class="string">cut_all:模式。True：全模式  False：精确模式（默认）</span></span><br><span class="line"><span class="string">HMM: 是否使用隐马尔科夫模型</span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">jieba.cut_for_search(sentence, HMM=<span class="literal">True</span>)</span><br><span class="line"><span class="comment">#返回Tokenizer类型，切分模式：搜索引擎模式</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">jieba.lcut</span><br><span class="line">jieba.lcut_for_search</span><br><span class="line"><span class="comment">#返回切分结果的列表（list），用法和前两个方法分别类似</span></span><br></pre></td></tr></table></figure><h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h4><h5 id="cut"><a href="#cut" class="headerlink" title="cut"></a>cut</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> jieba</span><br><span class="line">words=jieba.cut(<span class="string">'这是一个非常有趣的中文分词库'</span>)   </span><br><span class="line"><span class="comment">#&lt;generator object Tokenizer.cut at 0x7f01ca5322b0&gt;</span></span><br><span class="line"><span class="string">'/'</span>.join(words)   <span class="comment">#'这是/一个/非常/有趣/的/中文/分/词库'</span></span><br><span class="line"></span><br><span class="line">words=jieba.cut(<span class="string">'这是一个非常有趣的中文分词库'</span>,cut_all=<span class="literal">True</span>)   <span class="comment">#全模式</span></span><br><span class="line"><span class="string">'/'</span>.join(words)   <span class="comment">#'这/是/一个/非常/常有/有趣/的/中文/分词/词库'</span></span><br></pre></td></tr></table></figure><h5 id="cut-for-search"><a href="#cut-for-search" class="headerlink" title="cut_for_search"></a>cut_for_search</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> jieba</span><br><span class="line">words=jieba.cut_for_search(<span class="string">'这是一个非常有趣的中文分词库'</span>)</span><br><span class="line"><span class="string">'/'</span>.join(words)   <span class="comment">#'这是/一个/非常/有趣/的/中文/分/词库'</span></span><br></pre></td></tr></table></figure><p><em>注：</em>cut和cut_for_search方法返回的都是Tokenizer对象，需要使用join或list转为字符串或列表显示。</p><h5 id="lcut"><a href="#lcut" class="headerlink" title="lcut"></a>lcut</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> jieba</span><br><span class="line">jieba.lcut(<span class="string">'这是一个非常有趣的中文分词库'</span>)    </span><br><span class="line"><span class="comment">#['这是', '一个', '非常', '有趣', '的', '中文', '分', '词库']</span></span><br><span class="line">jieba.lcut(<span class="string">'这是一个非常有趣的中文分词库'</span>,cut_all=<span class="literal">True</span>)   <span class="comment">#全模式</span></span><br><span class="line"><span class="comment">#['这', '是', '一个', '非常', '常有', '有趣', '的', '中文', '分词', '词库']</span></span><br><span class="line"></span><br><span class="line">jieba.lcut(<span class="string">'这是一个非常有interesting趣的中文分词库'</span>,cut_all=<span class="literal">True</span>)</span><br><span class="line"><span class="comment">#['这', '是', '一个', '非常', '常有', 'interesting', '趣', '的', '中文', '分词', '词库']</span></span><br></pre></td></tr></table></figure><p><em>注：</em>若在输出中文字符串中包括英文字母、数字、符号等，相当于将句子断开，即使断开地方可以组成词语（比如：”有趣“），但是三种切分模式都不会将它组成词语。</p><h5 id="lcut-for-search"><a href="#lcut-for-search" class="headerlink" title="lcut_for_search"></a>lcut_for_search</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> jieba</span><br><span class="line">jieba.lcut_for_search(<span class="string">'这是一个非常有趣的中文分词库'</span>)</span><br><span class="line"><span class="comment">#['这是', '一个', '非常', '有趣', '的', '中文', '分', '词库']</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;用于中文词语切分的库。切分模式有以下三种：&lt;/p&gt;
&lt;p&gt;全模式：返回句子中所有可能的词语，可重复使用字。&lt;/p&gt;
&lt;p&gt;精确模式：将句子精确划分成多个词语，字不能复用。&lt;/p&gt;
&lt;p&gt;搜索引擎模式：在精确模式的基础上近一步划分长词&lt;/p&gt;
&lt;h4 id=&quot;常用方法&quot;&gt;&lt;a
      
    
    </summary>
    
    
      <category term="python模块" scheme="http://yoursite.com/categories/python%E6%A8%A1%E5%9D%97/"/>
    
    
      <category term="python" scheme="http://yoursite.com/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>hashlib 模块</title>
    <link href="http://yoursite.com/2020/02/23/hashlib%20%E6%A8%A1%E5%9D%97/"/>
    <id>http://yoursite.com/2020/02/23/hashlib%20%E6%A8%A1%E5%9D%97/</id>
    <published>2020-02-23T14:10:32.000Z</published>
    <updated>2020-02-23T15:45:46.050Z</updated>
    
    <content type="html"><![CDATA[<p>提供多种哈希算法的模块。</p><p><strong>哈希算法</strong>：又叫摘要算法，是一种给定输入计算出一种特殊的结果。哈希算法不可逆，比如输入一串字符串，输出一串奇怪的字符串，无法根据输出反向算出输入（除了暴力穷举破解）。</p><p>哈希算法可以用于校验文件一致性，对多个文件使用相同的哈希算法，若得到的结果相同，则表示文件完全相同，没有丢失或修改数据。</p><p>哈希算法有如下：<br>md5<br>sha1,sha224, sha256, sha384, sha512,<br>blake2b, blake2s<br>sha3_224, sha3_256, sha3_384, sha3_512<br>shake_128, shake_256……</p><p>在该模块中，以上算法都是类，可以调用产生相应的hash对象。</p><p>其中md5和sha1较常见，但是都可能发生碰撞。sha384 和sha512 在32位的平台上会较慢。<br><strong>碰撞</strong>：不同的输入产生了相同的Hash结果。</p><p>该模块产生的hash对象具有以下<strong>四种方法</strong>：</p><p>-update(data)：对输入字节更新哈希对象。更新不是替换，重复调用和将所有输入字符串拼起来一次性调用，产生相同结果。<br>-digest()：返回update方法中输入的hash结果，为bytes对象。<br>-hexdigest()：与digest()类似，但是仅包含十六进制数字，长度是digest结果的两倍。<br>-copy()：复制哈希对象并返回，可用于计算公共初始子字符串的数据hash结果。</p><h4 id="用法举例"><a href="#用法举例" class="headerlink" title="用法举例"></a>用法举例</h4><p>上文中已列举出了hashlib模块中的类（哈希算法），因为这些类的使用方法相同，下文仅以md5算法作为示例。</p><p><strong>注意：</strong>若输入字符串，需要<strong>编码</strong>。因为字符串是unicode对象，无法直接使用哈希算法！在字符串前加上b，将该字符串类型转为bytes类型，等价于使用‘utf-8’编码。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> hashlib</span><br><span class="line">password= hashlib.md5()</span><br><span class="line">password.update(<span class="string">b"abcdef123"</span>)   <span class="comment">#即：'abcdef123'.encode('utf-8')</span></span><br><span class="line">password.digest()     <span class="comment">#b'\xaa|\x9c\x12\xfct\tU\xefM\xfa\xd6p%\x0f\xf4'</span></span><br><span class="line">password.update(<span class="string">b"xyz"</span>)   <span class="comment">#和password.update(b"abcdef123xyz")产生的hash对象相同</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#也可以用如下方法直接输入文本</span></span><br><span class="line">password=hashlib.md5(<span class="string">'abcdef123'</span>.encode(<span class="string">'gbk'</span>))    <span class="comment">#字符串输入时需要编码</span></span><br><span class="line">password.hexdigest()  <span class="comment">#aa7c9c12fc740955ef4dfad670250ff4      32位</span></span><br><span class="line">password.digest()     <span class="comment">#b'\xaa|\x9c\x12\xfct\tU\xefM\xfa\xd6p%\x0f\xf4'    16位</span></span><br></pre></td></tr></table></figure><p>由以上输出可知，相同字符串编码方式不同，使用相同的hash算法产生的对象相同。</p><h5 id="盐"><a href="#盐" class="headerlink" title="盐"></a>盐</h5><p>使用哈希算法时，对密码加盐是一种加强安全性的手段，可以防止暴力破解明文密码。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> hashlib</span><br><span class="line">password=<span class="string">'abcdef123'</span>   <span class="comment">#原密码</span></span><br><span class="line">salt=<span class="string">'tgrcxn'</span>   </span><br><span class="line">salted_password=password+salt</span><br><span class="line">hashlib.md5(salted_password.encode(<span class="string">'ascii'</span>)).hexdigest()  <span class="comment">#对加盐的密码获得hash对象</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;提供多种哈希算法的模块。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;哈希算法&lt;/strong&gt;：又叫摘要算法，是一种给定输入计算出一种特殊的结果。哈希算法不可逆，比如输入一串字符串，输出一串奇怪的字符串，无法根据输出反向算出输入（除了暴力穷举破解）。&lt;/p&gt;
&lt;p&gt;哈希算法可以用于校验
      
    
    </summary>
    
    
      <category term="python模块" scheme="http://yoursite.com/categories/python%E6%A8%A1%E5%9D%97/"/>
    
    
      <category term="python" scheme="http://yoursite.com/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>time 模块</title>
    <link href="http://yoursite.com/2020/02/22/time%20%E6%A8%A1%E5%9D%97/"/>
    <id>http://yoursite.com/2020/02/22/time%20%E6%A8%A1%E5%9D%97/</id>
    <published>2020-02-21T16:31:32.000Z</published>
    <updated>2020-02-22T17:25:53.076Z</updated>
    
    <content type="html"><![CDATA[<p>包括多种处理不同格式时间数据的函数。</p><p>时间的<strong>标准表示形式</strong>有两种：一种是UTC（格林尼治标准时间GMT）表示，它可以是整数或浮点数（代表秒的分数）。在Unix上，通常是从1970年1月1日开始。</p><p>另一种是使用包括9个整型数字的元组表示，其中整型数字及其取值范围如下：</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">tm_year  (比如<span class="number">1998</span>)</span><br><span class="line">tm_mon   (<span class="number">1</span><span class="number">-12</span>)</span><br><span class="line">tm_mday  (<span class="number">1</span><span class="number">-31</span>)</span><br><span class="line">tm_hour  (<span class="number">0</span><span class="number">-23</span>)</span><br><span class="line">tm_min   (<span class="number">0</span><span class="number">-59</span>)</span><br><span class="line">tm_sec   (<span class="number">0</span><span class="number">-59</span>)</span><br><span class="line">tm_wday  (<span class="number">0</span><span class="number">-6</span>,星期一是<span class="number">0</span>)</span><br><span class="line">tm_yday  (<span class="number">1</span><span class="number">-366</span>，一年中的第几天)</span><br><span class="line">tm_isdst  DST(Daylight Savings Time) flag (<span class="number">-1</span>, <span class="number">0</span> <span class="keyword">or</span> <span class="number">1</span>)</span><br><span class="line">  <span class="number">0</span>：标准时区</span><br><span class="line">  <span class="number">1</span>：DST时区</span><br><span class="line"> <span class="number">-1</span>：基于日期和时间</span><br></pre></td></tr></table></figure><h4 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h4><p>time模块包括多种时间函数，下面仅介绍常用函数，包括clock、sleep、time、localtime、gmtime、asctime、ctime和strptime。</p><p>其中localtime和gmtime将时间戳转化为<strong>元组</strong>格式；asctime和ctime分别将元组格式和时间戳转化为<strong>字符串</strong>格式；strptime将任意字符串格式时间解析为<strong>元组</strong>格式。</p><p>函数的具体介绍见注释，示例见下文。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">time.clock() -&gt; floating point number</span><br><span class="line"><span class="comment">#返回自进程开始以来或自第一次调用clock（）以来的CPU时间或实时时间，精度取决于系统</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">time.sleep(seconds)</span><br><span class="line"><span class="comment">#延迟函数，输入为float类型，单位为秒</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">time.time() -&gt; floating point number</span><br><span class="line"><span class="comment">#返回时间戳，使用秒数表示。起始时间1970.1.1</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">time.localtime([seconds]) -&gt; (tm_year,tm_mon,tm_mday,tm_hour,tm_min,</span><br><span class="line">                                  tm_sec,tm_wday,tm_yday,tm_isdst)</span><br><span class="line"><span class="comment">#将输入时间戳转化为当地时间元组数据。若输入为空，则返回当前时间。</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">time.gmtime([seconds]) -&gt; (tm_year, tm_mon, tm_mday, tm_hour, tm_min,</span><br><span class="line">                               tm_sec, tm_wday, tm_yday, tm_isdst)</span><br><span class="line"><span class="comment">#将输入时间戳转化为GMT时间元组数据。若输入为空，则返回当前时间。</span></span><br></pre></td></tr></table></figure><p><em>注：</em>gmtime和localtime的区别是返回对象的时间时区不同，但是格式相同。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">time.asctime([tuple]) -&gt; string</span><br><span class="line"><span class="comment">#将输入时间元组数据(9个参数)转化为字符串格式。若输入为空，则返回当前时间字符串。</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">time.ctime(seconds) -&gt; string</span><br><span class="line"><span class="comment">#将输入时间戳转化为字符串格式。若输入为空，则返回当前时间字符串。</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">time.strptime(string, format) -&gt; struct_time</span><br><span class="line"><span class="comment">#根据format格式将字符串string解析为时间元组</span></span><br><span class="line"></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">格式化符号：</span></span><br><span class="line"><span class="string">%Y  年</span></span><br><span class="line"><span class="string">%m  月[01,12]</span></span><br><span class="line"><span class="string">%d  日[01,31]</span></span><br><span class="line"><span class="string">%H  小时[00,23]</span></span><br><span class="line"><span class="string">%M  分[00,59]</span></span><br><span class="line"><span class="string">%S  秒[00,61]</span></span><br><span class="line"><span class="string">%z  时区偏移时间</span></span><br><span class="line"><span class="string">%a  星期缩写</span></span><br><span class="line"><span class="string">%A  星期</span></span><br><span class="line"><span class="string">%b  月份缩写</span></span><br><span class="line"><span class="string">%B  月</span></span><br><span class="line"><span class="string">%I  小时（12小时制）[01,12]</span></span><br><span class="line"><span class="string">%p  AM或PM</span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure><h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h4><h5 id="clock"><a href="#clock" class="headerlink" title="clock"></a>clock</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line">time.clock()   <span class="comment">#93.811006</span></span><br></pre></td></tr></table></figure><h5 id="sleep"><a href="#sleep" class="headerlink" title="sleep"></a>sleep</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line">time.localtime().tm_sec   <span class="comment">#42</span></span><br><span class="line">time.sleep(<span class="number">2</span>)</span><br><span class="line">time.localtime().tm_sec   <span class="comment">#44</span></span><br><span class="line"><span class="comment">#相差2，表示休眠了2秒</span></span><br></pre></td></tr></table></figure><h5 id="time"><a href="#time" class="headerlink" title="time"></a>time</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line">time.time()    <span class="comment">#1582348453.2869315</span></span><br></pre></td></tr></table></figure><h5 id="localtime"><a href="#localtime" class="headerlink" title="localtime"></a>localtime</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line">time.localtime()   </span><br><span class="line"><span class="comment">#time.struct_time(tm_year=2020, tm_mon=2, tm_mday=22, tm_hour=13, tm_min=16, tm_sec=4, tm_wday=5, tm_yday=53, tm_isdst=0)</span></span><br><span class="line">time.localtime().tm_year</span><br><span class="line"><span class="comment">#2020   也可以直接这样调用属性</span></span><br></pre></td></tr></table></figure><h5 id="gmtime"><a href="#gmtime" class="headerlink" title="gmtime"></a>gmtime</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line">time.gmtime()</span><br><span class="line"><span class="comment">#time.struct_time(tm_year=2020, tm_mon=2, tm_mday=22, tm_hour=5, tm_min=16, tm_sec=4, tm_wday=5, tm_yday=53, tm_isdst=0)</span></span><br><span class="line"><span class="comment">#gmtime显示的是GMT，localtime显示的是中国时间（博主位置），中国位于东八区，所以差8小时</span></span><br></pre></td></tr></table></figure><h5 id="asctime"><a href="#asctime" class="headerlink" title="asctime"></a>asctime</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line">time.asctime()</span><br><span class="line"><span class="comment">#'Sun Feb 23 00:55:18 2020'</span></span><br><span class="line">time.asctime((<span class="number">2019</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">5</span>,<span class="number">16</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">53</span>,<span class="number">0</span>))</span><br><span class="line"><span class="comment">#'Sat Jan  1 05:16:04 2019'  参数不能缺少。输入时间可以不符合客观事实。</span></span><br></pre></td></tr></table></figure><h5 id="ctime"><a href="#ctime" class="headerlink" title="ctime"></a>ctime</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line">time.ctime(<span class="number">1582348453.2869315</span>)</span><br><span class="line"><span class="comment">#'Sat Feb 22 13:14:13 2020'</span></span><br></pre></td></tr></table></figure><h5 id="strptime"><a href="#strptime" class="headerlink" title="strptime"></a>strptime</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line">time.strptime(<span class="string">'2019/10/1 00:12:34'</span>,<span class="string">'%Y/%m/%d %H:%M:%S'</span>)</span><br><span class="line"><span class="comment">#time.struct_time(tm_year=2019, tm_mon=10, tm_mday=1, tm_hour=0, tm_min=12, tm_sec=34, tm_wday=1, tm_yday=274, tm_isdst=-1)</span></span><br><span class="line"><span class="comment">#可以根据给定时间字符串的格式进行解析，提取需要的时间信息</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;包括多种处理不同格式时间数据的函数。&lt;/p&gt;
&lt;p&gt;时间的&lt;strong&gt;标准表示形式&lt;/strong&gt;有两种：一种是UTC（格林尼治标准时间GMT）表示，它可以是整数或浮点数（代表秒的分数）。在Unix上，通常是从1970年1月1日开始。&lt;/p&gt;
&lt;p&gt;另一种是使用包括9
      
    
    </summary>
    
    
      <category term="python模块" scheme="http://yoursite.com/categories/python%E6%A8%A1%E5%9D%97/"/>
    
    
      <category term="python" scheme="http://yoursite.com/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>fractions 模块</title>
    <link href="http://yoursite.com/2020/02/20/fractions%20%E6%A8%A1%E5%9D%97/"/>
    <id>http://yoursite.com/2020/02/20/fractions%20%E6%A8%A1%E5%9D%97/</id>
    <published>2020-02-20T15:40:50.000Z</published>
    <updated>2020-02-20T15:57:35.736Z</updated>
    
    <content type="html"><![CDATA[<p>包括分数的表达和计算。</p><h4 id="常用类"><a href="#常用类" class="headerlink" title="常用类"></a>常用类</h4><p>Fraction类型支持基本内置运算，比如加、减、乘、除、绝对值、去上下界等。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Fraction(numbers.Rational)</span><br><span class="line"><span class="comment">#输入可以是一个小数、两个有理数(前者分子，后者分母)、字符型分数(分数线：'/')等。默认分子为0，分母为1。</span></span><br></pre></td></tr></table></figure><h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h4><h5 id="Fraction"><a href="#Fraction" class="headerlink" title="Fraction"></a>Fraction</h5><p>分子是numerator，分母是denominator，可以作为属性名分别查看。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> fractions</span><br><span class="line">fractions.Fraction(<span class="number">1.3</span>)</span><br><span class="line"><span class="comment">#输出：Fraction(5854679515581645, 4503599627370496)</span></span><br><span class="line">fractions.Fraction(<span class="number">5</span>,<span class="number">-4</span>)*fractions.Fraction(<span class="number">2</span>,<span class="number">1</span>)</span><br><span class="line"><span class="comment">#输出：Fraction(-5,2)</span></span><br><span class="line">fractions.Fraction(<span class="string">'5/7'</span>)</span><br><span class="line"><span class="comment">#输出：Fraction(5,7)</span></span><br><span class="line">fractions.Fraction(<span class="string">'5/2'</span>)+<span class="number">0.5</span></span><br><span class="line"><span class="comment">#输出：3.0</span></span><br></pre></td></tr></table></figure><p>注意：式子中只要有float，则输出float。否则输出Fraction。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;包括分数的表达和计算。&lt;/p&gt;
&lt;h4 id=&quot;常用类&quot;&gt;&lt;a href=&quot;#常用类&quot; class=&quot;headerlink&quot; title=&quot;常用类&quot;&gt;&lt;/a&gt;常用类&lt;/h4&gt;&lt;p&gt;Fraction类型支持基本内置运算，比如加、减、乘、除、绝对值、去上下界等。&lt;/p&gt;
&lt;fi
      
    
    </summary>
    
    
      <category term="python模块" scheme="http://yoursite.com/categories/python%E6%A8%A1%E5%9D%97/"/>
    
    
      <category term="python" scheme="http://yoursite.com/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>decimal 模块</title>
    <link href="http://yoursite.com/2020/02/20/decimal%20%E6%A8%A1%E5%9D%97/"/>
    <id>http://yoursite.com/2020/02/20/decimal%20%E6%A8%A1%E5%9D%97/</id>
    <published>2020-02-20T15:30:32.000Z</published>
    <updated>2020-02-20T15:37:09.347Z</updated>
    
    <content type="html"><![CDATA[<p>专门处理浮点型数字的模块，其精度高于python的浮点数类型。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0.1</span>+<span class="number">0.1</span>+<span class="number">0.1</span></span><br><span class="line"><span class="comment">#输出：0.30000000000000004  python浮点型数不能精确存储</span></span><br></pre></td></tr></table></figure><h4 id="常用类和方法"><a href="#常用类和方法" class="headerlink" title="常用类和方法"></a>常用类和方法</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">decimal.Decimal(builtins.object)</span><br><span class="line"><span class="comment">#输入可以是int，str、tuple或其他Decimal对象。若无输入，返回Decimal('0')</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">decimal.getcontext()</span><br><span class="line"><span class="comment">#Context(prec=28, rounding=ROUND_HALF_EVEN, Emin=-999999, Emax=999999, capitals=1, clamp=0, flags=[Inexact, FloatOperation, Rounded], traps=[InvalidOperation, DivisionByZero, Overflow])</span></span><br><span class="line"><span class="comment">#返回decimal类型的一些全局设置。最常用的是prec，表示精度，默认28。</span></span><br></pre></td></tr></table></figure><h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h4><h5 id="Decimal"><a href="#Decimal" class="headerlink" title="Decimal"></a>Decimal</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> decimal</span><br><span class="line">a=decimal.Decimal(<span class="string">'0.01'</span>)</span><br><span class="line">a+a+a</span><br><span class="line"><span class="comment">#Decimal('0.03')</span></span><br><span class="line">decimal.Decimal(<span class="number">0.01</span>)</span><br><span class="line"><span class="comment">#Decimal('0.01000000000000000020816681711721685132943093776702880859375')</span></span><br><span class="line"><span class="comment">#若直接输入浮点型，精度会出问题，需要转为str类型输入</span></span><br></pre></td></tr></table></figure><h5 id="getcontext-prec"><a href="#getcontext-prec" class="headerlink" title="getcontext().prec"></a>getcontext().prec</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> decimal</span><br><span class="line">decimal.getcontext().prec = <span class="number">4</span> </span><br><span class="line"><span class="comment">#设置小数点后保留4位</span></span><br><span class="line">decimal.Decimal(<span class="string">'0.123000'</span>)</span><br><span class="line"><span class="comment">#输出：Decimal('0.123000')   #精度设置不能影响固定输入</span></span><br><span class="line">decimal.Decimal(<span class="string">'0.123'</span>)*decimal.Decimal(<span class="string">'0.987'</span>)</span><br><span class="line"><span class="comment">#输出：Decimal('0.1214')</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;专门处理浮点型数字的模块，其精度高于python的浮点数类型。&lt;/p&gt;
&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;s
      
    
    </summary>
    
    
      <category term="python模块" scheme="http://yoursite.com/categories/python%E6%A8%A1%E5%9D%97/"/>
    
    
      <category term="python" scheme="http://yoursite.com/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>collections 模块</title>
    <link href="http://yoursite.com/2020/02/15/collections%20%E6%A8%A1%E5%9D%97/"/>
    <id>http://yoursite.com/2020/02/15/collections%20%E6%A8%A1%E5%9D%97/</id>
    <published>2020-02-14T16:25:32.000Z</published>
    <updated>2020-02-14T17:42:03.440Z</updated>
    
    <content type="html"><![CDATA[<p>该模块实现了专门的数据类型，为Python内置数据类型dict、list、set和tuple提供了替代方案。</p><h4 id="常用类和方法"><a href="#常用类和方法" class="headerlink" title="常用类和方法"></a>常用类和方法</h4><p>collections模块内包括很多类，因为这些类分别继承了内置类型，所以除了新定义的方法外，还能使用超类的方法。</p><p>常见类有四个，deque生成一个双向队列，可以高效的在首尾增删元素；defaultdict建立有默认键值的字典，普通字典若检索不存在的键会报错；OrderedDict建立有序字典，顺序是键的输入顺序；Counter返回一个有记数功能的字典。<br><em>注意：</em>defaultdict、OrderedDict和Counter都是dict的子类，本质是字典；deque本质是list。</p><p>namedtuple是一个方法，可以自定义tuple对象，定义元素名称和数量。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">collections.deque([iterable[, maxlen]]) --&gt; deque object</span><br><span class="line"><span class="comment">#生成的实例在list所有的方法上，新加了popleft、appendleft、extendleft方法</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">collections.defaultdict(default_factory[, ...]) --&gt; dict with default factory</span><br><span class="line"><span class="comment">#输入：str  默认键值：''</span></span><br><span class="line"><span class="comment">#输入：int  默认键值：0</span></span><br><span class="line"><span class="comment">#输入：list  默认键值：[]</span></span><br><span class="line"><span class="comment">#输入：set  默认键值：set()</span></span><br></pre></td></tr></table></figure><p><em>注意：</em>此处输入可以使用匿名函数lambda，指定具体的默认键值，而不是如上都是空值。举例见下文。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">collections.OrderedDict(builtins.dict)</span><br><span class="line"><span class="comment">#输入参数是一个python的dict类型变量，也可以不输入参数，直接建立一个空的有序字典</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">collections.Counter(builtins.dict)</span><br><span class="line"><span class="comment">#若有输入参数，则对其记数，输入参数可以是字符串、列表、字典、集合等；也可以没有输出参数，创建一个空的统计字典</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">collections.namedtuple(typename, field_names, *, verbose=<span class="literal">False</span>, rename=<span class="literal">False</span>, module=<span class="literal">None</span>)</span><br><span class="line"><span class="comment">#返回对象具有tuple的不变性，同时可以使用命名引用元素</span></span><br></pre></td></tr></table></figure><h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h4><h5 id="deque"><a href="#deque" class="headerlink" title="deque"></a>deque</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> collections</span><br><span class="line">data=collections.deque([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>])</span><br><span class="line"><span class="comment">#deque([1, 2, 3])</span></span><br><span class="line">data.append(<span class="number">4</span>)</span><br><span class="line">data.appendleft(<span class="number">0</span>)</span><br><span class="line"><span class="comment">#deque([0, 1, 2, 3, 4])</span></span><br><span class="line">data.pop()</span><br><span class="line">data.popleft()</span><br><span class="line"><span class="comment">#deque([1, 2, 3])</span></span><br><span class="line"><span class="comment">#deque可以生成一个双向队列，首尾均可以方便的添加、删除元素。</span></span><br><span class="line"><span class="comment">#输入若为字符串，则自动转为列表</span></span><br></pre></td></tr></table></figure><h5 id="defaultdict"><a href="#defaultdict" class="headerlink" title="defaultdict"></a>defaultdict</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> collections</span><br><span class="line">data=collections.defaultdict(str)</span><br><span class="line">data  <span class="comment"># defaultdict(str, &#123;&#125;)  表示生成了一个默认键值为''的字典</span></span><br><span class="line">data[<span class="string">'a'</span>]  <span class="comment"># '' 因为字典中没有'a'键，输出空字符串</span></span><br><span class="line">data=collections.defaultdict(<span class="keyword">lambda</span>: <span class="number">5</span>)</span><br><span class="line"><span class="comment">#默认键值为5</span></span><br><span class="line">data=collections.defaultdict(<span class="keyword">lambda</span>: [<span class="number">1</span>,<span class="number">2</span>])</span><br><span class="line"><span class="comment">#默认键值为[1,2]</span></span><br></pre></td></tr></table></figure><h5 id="OrderedDict"><a href="#OrderedDict" class="headerlink" title="OrderedDict"></a>OrderedDict</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> collections</span><br><span class="line">data=collections.OrderedDict()</span><br><span class="line">data[<span class="string">'c'</span>]=<span class="number">1</span></span><br><span class="line">data[<span class="string">'b'</span>]=<span class="number">1</span></span><br><span class="line">data[<span class="string">'a'</span>]=<span class="number">1</span></span><br><span class="line">data    <span class="comment"># OrderedDict([('c', 1), ('b', 1), ('a', 1)])  字典内部顺序取决于输入顺序</span></span><br></pre></td></tr></table></figure><h5 id="Counter"><a href="#Counter" class="headerlink" title="Counter"></a>Counter</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> collections</span><br><span class="line">collections.Counter(<span class="string">'445322264'</span>)</span><br><span class="line"><span class="comment">#Counter(&#123;'4': 3, '5': 1, '3': 1, '2': 3, '6': 1&#125;)  对字符串进行了统计的字典</span></span><br><span class="line">collections.Counter([<span class="string">'abc'</span>,<span class="string">'ss'</span>,<span class="string">'abc'</span>,<span class="string">'s'</span>,<span class="string">'ss'</span>])</span><br><span class="line"><span class="comment">#Counter(&#123;'abc': 2, 'ss': 2, 's': 1&#125;)</span></span><br><span class="line">collections.Counter(<span class="string">'445322264'</span>).most_common(<span class="number">3</span>)</span><br><span class="line"><span class="comment">#[('4', 3), ('2', 3), ('5', 1)]   </span></span><br><span class="line"><span class="comment">#most_common是Counter类的方法,可以列出n个最多的元素，从大到小排列，若n为None，则全列出。</span></span><br></pre></td></tr></table></figure><h5 id="namedtuple"><a href="#namedtuple" class="headerlink" title="namedtuple"></a>namedtuple</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> collections</span><br><span class="line">coordinate=collections.namedtuple(<span class="string">'coordinate'</span>,[<span class="string">'x'</span>,<span class="string">'y'</span>,<span class="string">'z'</span>])</span><br><span class="line">p=coordinate(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>)</span><br><span class="line">p.x  <span class="comment"># 1</span></span><br><span class="line">p    <span class="comment"># coordinate(x=1,y=2,z=3)</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;该模块实现了专门的数据类型，为Python内置数据类型dict、list、set和tuple提供了替代方案。&lt;/p&gt;
&lt;h4 id=&quot;常用类和方法&quot;&gt;&lt;a href=&quot;#常用类和方法&quot; class=&quot;headerlink&quot; title=&quot;常用类和方法&quot;&gt;&lt;/a&gt;常用类和方法
      
    
    </summary>
    
    
      <category term="python模块" scheme="http://yoursite.com/categories/python%E6%A8%A1%E5%9D%97/"/>
    
    
      <category term="python" scheme="http://yoursite.com/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>shelve 模块</title>
    <link href="http://yoursite.com/2020/02/14/shelve%20%E6%A8%A1%E5%9D%97/"/>
    <id>http://yoursite.com/2020/02/14/shelve%20%E6%A8%A1%E5%9D%97/</id>
    <published>2020-02-13T16:19:44.000Z</published>
    <updated>2020-02-13T17:18:50.545Z</updated>
    
    <content type="html"><![CDATA[<p>一种简单的持久化存储方式，将数据存储至磁盘。产生类似字典的对象。比pickle，json模块简单。</p><h4 id="常用函数"><a href="#常用函数" class="headerlink" title="常用函数"></a>常用函数</h4><p>模块包含方法只有一个open，用来打开指定文件，可读可写，返回对象类似字典。打开的文件后缀名是<strong>*.db</strong>，输入时可不必输入后缀名。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">shelve.open(filename, flag=<span class="string">'c'</span>, protocol=<span class="literal">None</span>, writeback=<span class="literal">False</span>)</span><br><span class="line"><span class="comment">#flag是文件打开模式。默认为c，可读写，文件不存在则创建；r：只读；w：只写；n：创建新的空文件，可读写</span></span><br><span class="line"><span class="comment">#writeback：默认为False。若为True，将所有从.db中读取的对象存放到一个内存缓存中</span></span><br></pre></td></tr></table></figure><p><strong>注意：</strong>键必须是字符串类型，值可以是python内的所有数据类型。</p><h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h4><h5 id="open"><a href="#open" class="headerlink" title="open"></a>open</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> shelve</span><br><span class="line">data=shelve.open(<span class="string">'data'</span>)</span><br><span class="line">data[<span class="string">'a'</span>]=<span class="number">1</span></span><br><span class="line">data[<span class="string">'b'</span>]=<span class="string">'abc'</span></span><br><span class="line">data[<span class="string">'c'</span>]=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]</span><br><span class="line">data[<span class="string">'d'</span>]=&#123;<span class="string">'a'</span>:<span class="number">1</span>,<span class="string">'b'</span>:<span class="number">2</span>&#125;</span><br><span class="line"><span class="comment">#list(data.items())</span></span><br><span class="line"><span class="comment">#输出：[('b','abc'),('d',&#123;'a': 1,'b': 2&#125;),('a',1),('c',[1,2,3,4])]</span></span><br><span class="line"><span class="comment">#因为返回对象类似字典，因此可以使用字典的方法，比如items()</span></span><br><span class="line">data.close()</span><br><span class="line"><span class="comment">#最后要关闭文件</span></span><br></pre></td></tr></table></figure><p><strong>关于参数writeback</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">data=shelve.open(<span class="string">'data'</span>)</span><br><span class="line">data[<span class="string">'c'</span>].append(<span class="number">5</span>)</span><br><span class="line">print(data[<span class="string">'c'</span>])</span><br><span class="line"><span class="comment">#输出：[1,2,3,4]</span></span><br><span class="line">data.close()</span><br><span class="line">data=shelve.open(<span class="string">'data'</span>,writeback=<span class="literal">True</span>)</span><br><span class="line">data[<span class="string">'c'</span>].append(<span class="number">5</span>)</span><br><span class="line">print(data[<span class="string">'c'</span>])</span><br><span class="line"><span class="comment">#输出：[1,2,3,4,5]</span></span><br><span class="line"><span class="comment">#当writeback设为True时，可以原地修改db中的可变对象了</span></span><br></pre></td></tr></table></figure><p>writeback设为True时，一次将所有内容读到缓存，消耗了空间和时间，但是可以直接修改其中内容并保存。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;一种简单的持久化存储方式，将数据存储至磁盘。产生类似字典的对象。比pickle，json模块简单。&lt;/p&gt;
&lt;h4 id=&quot;常用函数&quot;&gt;&lt;a href=&quot;#常用函数&quot; class=&quot;headerlink&quot; title=&quot;常用函数&quot;&gt;&lt;/a&gt;常用函数&lt;/h4&gt;&lt;p&gt;模块包含方
      
    
    </summary>
    
    
      <category term="python模块" scheme="http://yoursite.com/categories/python%E6%A8%A1%E5%9D%97/"/>
    
    
      <category term="python" scheme="http://yoursite.com/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>copy 模块</title>
    <link href="http://yoursite.com/2020/02/13/copy%20%E6%A8%A1%E5%9D%97/"/>
    <id>http://yoursite.com/2020/02/13/copy%20%E6%A8%A1%E5%9D%97/</id>
    <published>2020-02-12T16:05:32.000Z</published>
    <updated>2020-02-13T05:49:19.747Z</updated>
    
    <content type="html"><![CDATA[<p>包括深拷贝和浅拷贝操作的模块。</p><p>首先要分清<strong>变量</strong>和<strong>对象</strong>的概念，python中的<strong>变量类似指针</strong>，指向各个对象。比如a=2，是有一个名为a的变量指向了2这个对象；x=[1,2,3]中变量x指向对象[1,2,3]。</p><p>然后，在python中，int、float、str、tuple和bool等都是<strong>不可变对象</strong>，list、set和dict是<strong>可变对象</strong>。可变对象可以原地修改，而不可变对象不能原地修改。</p><p>指向不可变对象的变量，若要修改，会指向内存处的新对象。可变对象是在原内存处修改，此时，若有不同变量指向同一可变对象，则这些变量都会被修改。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#下面使用str和list类型举例：</span></span><br><span class="line">a=<span class="string">'abc'</span></span><br><span class="line">b=a</span><br><span class="line">a=<span class="string">'xyz'</span></span><br><span class="line">print(a,b)</span><br><span class="line"><span class="comment">#输出：xyz abc 可见a，b指向了不同的对象</span></span><br><span class="line">x=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">y=x</span><br><span class="line">x[<span class="number">0</span>]=<span class="number">10</span></span><br><span class="line">print(x,y)</span><br><span class="line"><span class="comment">#输出：[10, 2, 3] [10, 2, 3] 可见修改x[0]同时改变了y[0]</span></span><br></pre></td></tr></table></figure><p>由此可见，使用 ’ = ‘ 复制变量对于不可变对象没问题，但是对于可变对象确不行。</p><p>接下来引入深拷贝和浅拷贝概念：</p><p><strong>深拷贝</strong>：将对象完全复制生成一个新的对象，是我们所理解的复制意义。</p><p><strong>浅拷贝</strong>：类似于复制了一个指针，如果原变量改变，复制变量也被修改。</p><h4 id="常用函数与示例"><a href="#常用函数与示例" class="headerlink" title="常用函数与示例"></a>常用函数与示例</h4><p>常用函数包括两个，copy是浅拷贝方法，deepcopy是深拷贝方法，完全复制对象。</p><p>对于普通对象，copy和deepcopy没有区别，但是对于嵌套的复杂结构，比如list内嵌套了list，两者就存在差异。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> copy</span><br><span class="line">x=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">y=copy.copy(x)</span><br><span class="line">x[<span class="number">0</span>]=<span class="number">10</span></span><br><span class="line">print(x,y)</span><br><span class="line"><span class="comment">#输出：[10, 2, 3] [1, 2, 3] 可以看到与上文中的区别，修改x不会影响y</span></span><br><span class="line"><span class="comment">#此处使用deepcopy也行</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> copy</span><br><span class="line">x=[<span class="number">1</span>,[<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>],<span class="number">5</span>]</span><br><span class="line">y=copy.copy(x)</span><br><span class="line">x[<span class="number">0</span>]=<span class="number">10</span></span><br><span class="line">x[<span class="number">1</span>][<span class="number">1</span>]=<span class="number">20</span></span><br><span class="line">print(x,y)</span><br><span class="line"><span class="comment">#输出：[10, [2, 20, 4], 5] [1, [2, 20, 4], 5]</span></span><br><span class="line"><span class="comment">#当list中嵌套list时，对于浅拷贝，修改x[0]不会产生影响，但是嵌套的list仍然会受到影响，y[1][1]也更改了</span></span><br><span class="line">x=[<span class="number">1</span>,[<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>],<span class="number">5</span>]</span><br><span class="line">y=copy.deepcopy(x)</span><br><span class="line">x[<span class="number">0</span>]=<span class="number">10</span></span><br><span class="line">x[<span class="number">1</span>][<span class="number">1</span>]=<span class="number">20</span></span><br><span class="line">print(x,y)</span><br><span class="line"><span class="comment">#输出：[10, [2, 20, 4], 5] [1, [2, 3, 4], 5]</span></span><br><span class="line"><span class="comment">#使用深拷贝，y[1][1]仍然是原来的值。x和y指向两个不同的对象。</span></span><br></pre></td></tr></table></figure><p>总之，对于不可变对象可以直接使用’=‘复制变量；简单可变对象，可以使用浅拷贝；对于可变对象且存在嵌套结构，则需要深拷贝，从而完全创建一个新对象。</p><p>另外，对于简单可变对象，比如list的浅拷贝还有一种简单方式，不必导入copy模块，即<strong>切片</strong>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">x=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">y=x[:]</span><br><span class="line">x[<span class="number">0</span>]=<span class="number">10</span></span><br><span class="line">print(x,y)</span><br><span class="line"><span class="comment">#输出：[10, 2, 3] [1, 2, 3]</span></span><br><span class="line"><span class="comment">#可见只需在x后加上[:],将x全部切出并创建了新的对象</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;包括深拷贝和浅拷贝操作的模块。&lt;/p&gt;
&lt;p&gt;首先要分清&lt;strong&gt;变量&lt;/strong&gt;和&lt;strong&gt;对象&lt;/strong&gt;的概念，python中的&lt;strong&gt;变量类似指针&lt;/strong&gt;，指向各个对象。比如a=2，是有一个名为a的变量指向了2这个对象；x=
      
    
    </summary>
    
    
      <category term="python模块" scheme="http://yoursite.com/categories/python%E6%A8%A1%E5%9D%97/"/>
    
    
      <category term="python" scheme="http://yoursite.com/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>glob 模块</title>
    <link href="http://yoursite.com/2020/02/11/glob%20%E6%A8%A1%E5%9D%97/"/>
    <id>http://yoursite.com/2020/02/11/glob%20%E6%A8%A1%E5%9D%97/</id>
    <published>2020-02-11T12:31:52.000Z</published>
    <updated>2020-02-13T05:49:51.929Z</updated>
    
    <content type="html"><![CDATA[<p>目录文件名查找模块。在查找路径中使用通配符，可以找到满足指定条件的所有文件路径名。</p><h4 id="常用函数"><a href="#常用函数" class="headerlink" title="常用函数"></a>常用函数</h4><p>该模块包括3个函数，glob用于一次性返回指定路径匹配的文件名；iglob和glob功能一样，同样查找匹配的文件名，但是返回对象是迭代器，即每次输出一个；escape在路径中选出*、？、[ 符号。</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">glob.glob(pathname, *, recursive=False)   -&gt;   list</span><br></pre></td></tr></table></figure><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">glob.iglob(pathname, *, recursive=False)  -&gt;   iterator object</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">glob.escape(pathname)</span><br></pre></td></tr></table></figure><p>输入路径名支持通配符：</p><table><thead><tr><th>符号</th><th>含义</th></tr></thead><tbody><tr><td>*</td><td>匹配0到多个字符</td></tr><tr><td>？</td><td>匹配1个字符</td></tr><tr><td>[a-z],[0-9]等</td><td>表示范围，匹配1个字符</td></tr></tbody></table><h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h4><h5 id="glob"><a href="#glob" class="headerlink" title="glob"></a>glob</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> glob</span><br><span class="line">glob.glob(<span class="string">'/root/data/test1/65*.csv'</span>)</span><br><span class="line"><span class="comment">#输出‘/root/data/test1/’目录下所有65开头的csv文件</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">['/root/data/test1/65bbf6d7a405afa6348d.csv',</span></span><br><span class="line"><span class="string"> '/root/data/test1/659a34281cc2fe85020e.csv',</span></span><br><span class="line"><span class="string"> '/root/data/test1/65bc1c8c4975caff0964.csv',</span></span><br><span class="line"><span class="string"> '/root/data/test1/65657f592decf6d14040.csv',</span></span><br><span class="line"><span class="string"> '/root/data/test1/65f046177650d25f7b42.csv']</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line">glob.glob(<span class="string">'/root/*/[0-9].*'</span>)</span><br><span class="line"><span class="comment">#返回列表包括root的所有子目录中所有以一个数字命名的各种类型文件</span></span><br></pre></td></tr></table></figure><p>上文目录都是Linux系统下，Windows下目录格式不同，为了防转义，可以在字符串前加”r”<br>比如：r’C:\Users\USER\OneDrive\桌面*.txt’  或  ‘C:\Users\USER\OneDrive\桌面\*.txt’</p><h5 id="iglob"><a href="#iglob" class="headerlink" title="iglob"></a>iglob</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> glob</span><br><span class="line">a=glob.iglob(<span class="string">'/root/data/test1/65*.csv'</span>) </span><br><span class="line"><span class="comment">#&lt;generator object _iglob at 0x7f01d5820d00&gt;</span></span><br><span class="line">next(a)</span><br><span class="line"><span class="comment">#输出：'/root/data/test1/65bbf6d7a405afa6348d.csv'</span></span><br><span class="line">next(a)</span><br><span class="line"><span class="comment">#输出：'/root/data/test1/659a34281cc2fe85020e.csv'</span></span><br></pre></td></tr></table></figure><h5 id="escape"><a href="#escape" class="headerlink" title="escape"></a>escape</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> glob</span><br><span class="line">glob.escape(<span class="string">'C:\\Users\\USER\\One?riv[a-f]\\桌面\\*.pdf'</span>)</span><br><span class="line"><span class="comment">#输出：'C:\\Users\\USER\\One[?]riv[[]a-f]\\桌面\\[*].pdf'</span></span><br><span class="line"><span class="comment">#？*[三个符号会被[]所包括</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;目录文件名查找模块。在查找路径中使用通配符，可以找到满足指定条件的所有文件路径名。&lt;/p&gt;
&lt;h4 id=&quot;常用函数&quot;&gt;&lt;a href=&quot;#常用函数&quot; class=&quot;headerlink&quot; title=&quot;常用函数&quot;&gt;&lt;/a&gt;常用函数&lt;/h4&gt;&lt;p&gt;该模块包括3个函数，glo
      
    
    </summary>
    
    
      <category term="python模块" scheme="http://yoursite.com/categories/python%E6%A8%A1%E5%9D%97/"/>
    
    
      <category term="python" scheme="http://yoursite.com/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>os 模块</title>
    <link href="http://yoursite.com/2020/02/08/os%20%E6%A8%A1%E5%9D%97/"/>
    <id>http://yoursite.com/2020/02/08/os%20%E6%A8%A1%E5%9D%97/</id>
    <published>2020-02-08T05:07:32.000Z</published>
    <updated>2020-02-13T07:07:31.312Z</updated>
    
    <content type="html"><![CDATA[<p>os：operating system</p><p>包括系统和目录的操作函数，可以让python访问操作系统。</p><p>os模块包括子模块path，主要用于获取文件的属性。</p><p>因为os和os.path模块包含函数及属性较多，本文仅列举部分，直接通过举例介绍函数功能。</p><h4 id="常用函数"><a href="#常用函数" class="headerlink" title="常用函数"></a>常用函数</h4><p>下文分为查找、创建、删除、修改和os.path五个部分，分别包括不同类型功能的函数。</p><h5 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h5><p>包括对系统、目录或文件的查找操作和属性。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line">os.getcwd()</span><br><span class="line"><span class="comment">#获得当前工作路径</span></span><br><span class="line"><span class="comment">#例如：'/root/python workspace'</span></span><br><span class="line"><span class="comment">#笔者使用Linux系统</span></span><br><span class="line">os.getcwdb()</span><br><span class="line"><span class="comment">#返回当前工作路径的Unicode对象</span></span><br><span class="line"><span class="string">b'/root/python workspace'</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line">os.name</span><br><span class="line"><span class="comment">#返回操作系统，若是Windows，则输出'nt'；若是Linux，则输出'posix'</span></span><br><span class="line"><span class="comment">#注意这不算是函数，是属性，因此结尾没有括号</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line">os.sep</span><br><span class="line"><span class="comment">#Windows系统输出：'\\'；Linux系统输出：'/'</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line">os.listdir(<span class="string">'/root/python workspace'</span>)</span><br><span class="line"><span class="comment">#输出：['Untitled1.ipynb','.ipynb_checkpoints',</span></span><br><span class="line"><span class="comment">#'tmp.pk','Untitled.ipynb']</span></span><br><span class="line"><span class="comment">#返回列表，包括输入路径内的文件、文件夹的名字。</span></span><br></pre></td></tr></table></figure><h5 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line">os.mkdir(<span class="string">'/root/python workspace/test'</span>)</span><br><span class="line"><span class="comment">#在目录 /root/python workspace 下创建一个名为test的文件夹</span></span><br></pre></td></tr></table></figure><p><em>注意：若创建、删除等操作是在当前工作路径下，则输入可以直接输入文件或文件夹名称，不必包括路径。如上文可以直接输入’test‘。</em></p><h5 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line">os.rmdir(<span class="string">'test'</span>)</span><br><span class="line"><span class="comment">#删除当前工作目录下名为test的空文件夹</span></span><br><span class="line"><span class="comment">#注意：删除对象必须是空的文件夹</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line">os.remove(<span class="string">'/root/new/tmp.pk'</span>)</span><br><span class="line"><span class="comment">#删除路径为'/root/new/’下的tmp.pk文件</span></span><br><span class="line"><span class="comment">#注意：删除对象必须是一个存在的文件</span></span><br></pre></td></tr></table></figure><h5 id="修改"><a href="#修改" class="headerlink" title="修改"></a>修改</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line">os.rename(<span class="string">'test'</span>,<span class="string">'test1'</span>)</span><br><span class="line"><span class="comment">#将当前路径下名为test的文件或文件夹改名为test1</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line">os.chdir(<span class="string">'/root'</span>)</span><br><span class="line"><span class="comment">#修改当前工作路径</span></span><br><span class="line">os.getcwd()</span><br><span class="line"><span class="comment">#输出：'/root'</span></span><br></pre></td></tr></table></figure><h4 id="os-path"><a href="#os-path" class="headerlink" title="os.path"></a>os.path</h4><p>os.path模块可以获取文件属性信息。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line">file=<span class="string">'/root/python workspace/test'</span></span><br></pre></td></tr></table></figure><p>因为该模块函数较多，因此列表展示其部分功能。举例输入文件如上，file包括一个文件夹的路径，输出见下表第三列。</p><table><thead><tr><th>方法</th><th>说明</th><th>输出举例</th></tr></thead><tbody><tr><td>os.path.abspath(file)</td><td>返回绝对路径</td><td>‘/root/python workspace/test’</td></tr><tr><td>os.path.basename(file)</td><td>返回文件名</td><td>‘test’</td></tr><tr><td>os.path.dirname(file)</td><td>返回文件路径</td><td>‘/root/python workspace’</td></tr><tr><td>os.path.exists(file)</td><td>判断是否存在该路径</td><td>True</td></tr><tr><td>os.path.getatime(file)</td><td>返回最近访问时间(秒)</td><td>1581350083.6365876</td></tr><tr><td>s.path.getctime(file)</td><td>返回文件创建时间</td><td>1581350083.6365876</td></tr><tr><td>os.path.getmtime(file)</td><td>返回最近文件修改时间</td><td>1581350083.6365876</td></tr><tr><td>os.path.getsize(file)</td><td>返回文件大小（字节）</td><td>4096</td></tr><tr><td>os.path.isabs(file)</td><td>判断是否为绝对路径</td><td>True</td></tr><tr><td>os.path.isfile(file)</td><td>判断路径是否为文件</td><td>False</td></tr><tr><td>os.path.isdir(file)</td><td>判断路径是否为目录</td><td>True</td></tr><tr><td>os.path.islink(file)</td><td>判断路径是否为链接</td><td>False</td></tr><tr><td>os.path.normcase(file)</td><td>转换输入路径的大小写和斜杠</td><td>‘/root/python workspace/test’</td></tr><tr><td>os.path.normpath(file)</td><td>规范输入字符串形式</td><td>‘/root/python workspace/test’</td></tr><tr><td>os.path.split(file)</td><td>把路径分割成目录和文件名</td><td>(‘/root/python workspace’, ‘test’)</td></tr></tbody></table><p>除了上述方法外，os.path还包括连接文件名、判断是否相同文件及目录等方法。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;os：operating system&lt;/p&gt;
&lt;p&gt;包括系统和目录的操作函数，可以让python访问操作系统。&lt;/p&gt;
&lt;p&gt;os模块包括子模块path，主要用于获取文件的属性。&lt;/p&gt;
&lt;p&gt;因为os和os.path模块包含函数及属性较多，本文仅列举部分，直接通过举例介
      
    
    </summary>
    
    
      <category term="python模块" scheme="http://yoursite.com/categories/python%E6%A8%A1%E5%9D%97/"/>
    
    
      <category term="python" scheme="http://yoursite.com/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>random 模块</title>
    <link href="http://yoursite.com/2020/02/08/random%20%E6%A8%A1%E5%9D%97/"/>
    <id>http://yoursite.com/2020/02/08/random%20%E6%A8%A1%E5%9D%97/</id>
    <published>2020-02-08T05:07:32.000Z</published>
    <updated>2020-02-13T07:07:20.279Z</updated>
    
    <content type="html"><![CDATA[<p>包括生成随机对象的函数。</p><h4 id="常用函数"><a href="#常用函数" class="headerlink" title="常用函数"></a>常用函数</h4><p>部分函数具体介绍和示例见下文。randint返回随机整数；uniform和random返回随机浮点数；choice、sample和randrange从原序列中随机选择元素并返回；shuffle打乱原输入列表的顺序。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">random.randint(a,b)</span><br><span class="line"><span class="comment">#随机返回[a,b]间的一个数，包括a和b</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">random.randrange(start, stop=<span class="literal">None</span>, step=<span class="number">1</span>)</span><br><span class="line"><span class="comment">#随机返回range生成的序列中的一个</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">random.choice(seq)</span><br><span class="line"><span class="comment">#随机选择非空序列中的一个元素</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">random.sample(population, k)</span><br><span class="line"><span class="comment">#从序列或集合population中随机返回k个元素</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">random.shuffle(x, random=<span class="literal">None</span>)</span><br><span class="line"><span class="comment">#将列表x随机打乱顺序，返回random(默认为None)</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">random.random()</span><br><span class="line"><span class="comment">#随机返回[0,1)间的一个浮点数,不包括1</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">random.uniform(a,b)</span><br><span class="line"><span class="comment">#随机返回[a,b]间的一个浮点数</span></span><br></pre></td></tr></table></figure><h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h4><h5 id="randint"><a href="#randint" class="headerlink" title="randint"></a>randint</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> random</span><br><span class="line">random.randint(<span class="number">1</span>,<span class="number">10</span>)</span><br><span class="line"><span class="comment">#输出1~10间任意数，包括1和10</span></span><br></pre></td></tr></table></figure><h5 id="randrange"><a href="#randrange" class="headerlink" title="randrange"></a>randrange</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> random</span><br><span class="line">random.randrange(<span class="number">1</span>,<span class="number">10</span>)</span><br><span class="line"><span class="comment">#在[1,10)中随机返回1个数</span></span><br><span class="line">random.randrange(<span class="number">5</span>)</span><br><span class="line"><span class="comment">#在[0,5)中随机返回1个数（若不指定初值，则从0开始）</span></span><br><span class="line">random.randrange(<span class="number">1</span>,<span class="number">10</span>,<span class="number">2</span>)</span><br><span class="line"><span class="comment">#在[1,3,5,7,9]中随机返回1个数(因为步长为2)</span></span><br></pre></td></tr></table></figure><h5 id="choice"><a href="#choice" class="headerlink" title="choice"></a>choice</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> random</span><br><span class="line">random.choice(<span class="string">'asdf'</span>)</span><br><span class="line">random.choice([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>])</span><br><span class="line"><span class="comment">#以上都随机输出序列中的一个元素</span></span><br><span class="line"><span class="comment">#输入不能是set类型</span></span><br></pre></td></tr></table></figure><h5 id="sample"><a href="#sample" class="headerlink" title="sample"></a>sample</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> random</span><br><span class="line">random.sample(<span class="string">'abcd'</span>,<span class="number">2</span>)</span><br><span class="line"><span class="comment">#输出：['a','c']</span></span><br><span class="line">random.sample([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>],<span class="number">3</span>)</span><br><span class="line"><span class="comment">#输出：[3,1,5]</span></span><br><span class="line"><span class="comment">#以上均随机返回指定数量元素的列表</span></span><br></pre></td></tr></table></figure><h5 id="shuffle"><a href="#shuffle" class="headerlink" title="shuffle"></a>shuffle</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> random</span><br><span class="line">a=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>]</span><br><span class="line">random.shuffle(a)</span><br><span class="line">print(a)</span><br><span class="line"><span class="comment">#输出：[3, 6, 5, 1, 2, 4]   随机打乱输入对象</span></span><br><span class="line"><span class="comment">#输入是list类型，不能是str、set类型等</span></span><br></pre></td></tr></table></figure><h5 id="random"><a href="#random" class="headerlink" title="random"></a>random</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> random</span><br><span class="line">random.random()</span><br><span class="line"><span class="comment">#注意此处random是函数名，不能直接random()</span></span><br></pre></td></tr></table></figure><h5 id><a href="#" class="headerlink" title></a></h5>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;包括生成随机对象的函数。&lt;/p&gt;
&lt;h4 id=&quot;常用函数&quot;&gt;&lt;a href=&quot;#常用函数&quot; class=&quot;headerlink&quot; title=&quot;常用函数&quot;&gt;&lt;/a&gt;常用函数&lt;/h4&gt;&lt;p&gt;部分函数具体介绍和示例见下文。randint返回随机整数；uniform和rando
      
    
    </summary>
    
    
      <category term="python模块" scheme="http://yoursite.com/categories/python%E6%A8%A1%E5%9D%97/"/>
    
    
      <category term="python" scheme="http://yoursite.com/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>itertools 模块</title>
    <link href="http://yoursite.com/2020/02/06/itertools%20%E6%A8%A1%E5%9D%97/"/>
    <id>http://yoursite.com/2020/02/06/itertools%20%E6%A8%A1%E5%9D%97/</id>
    <published>2020-02-06T14:35:32.000Z</published>
    <updated>2020-02-13T07:08:43.609Z</updated>
    
    <content type="html"><![CDATA[<p>包括创建和使用迭代器的函数。</p><p>迭代器是可以记录遍历位置。迭代器对象从集合的第一个元素开始访问，直到所有的元素被访问完结束。迭代器只能往前不会后退。</p><h4 id="常用函数"><a href="#常用函数" class="headerlink" title="常用函数"></a>常用函数</h4><p>itertools模块包括较多关于迭代器创建、合并、切分等操作的函数，这里介绍如下几个。</p><p>permutations生成一个迭代对象的全排列； chain连接多个列表或者迭代器；cycle对输入对象生成循环迭代对象；count基于给定初值和步长，进行无限迭代；islice指定起、终点、步长的迭代器。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">itertools.permutations(iterable,r=None) --&gt; permutations object</span><br><span class="line"><span class="comment">#r表示迭代器中元素的长度</span></span><br></pre></td></tr></table></figure><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">itertools.chain(*iterables) --&gt; chain object</span><br></pre></td></tr></table></figure><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">itertools.cycle(iterable) --&gt; cycle object</span><br></pre></td></tr></table></figure><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">itertools.count(start=0,step=1) --&gt; count object</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">itertools.islice(iterable,start,stop,step=1) --&gt; islice object</span><br><span class="line"><span class="comment">#类似切片操作，但是输出为迭代器对象。</span></span><br></pre></td></tr></table></figure><p>注意：对于迭代对象的输出，有限迭代对象可以转化为list，直接一次性输出。或者利用循环遍历结果等方法。内置函数next()可以用来输出迭代对象。</p><h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h4><h5 id="permutations"><a href="#permutations" class="headerlink" title="permutations"></a>permutations</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> itertools</span><br><span class="line">data=itertools.permutations(<span class="string">'abc'</span>)</span><br><span class="line">list(data)</span><br><span class="line"><span class="comment">#输出：</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">[('a', 'b', 'c'),</span></span><br><span class="line"><span class="string"> ('a', 'c', 'b'),</span></span><br><span class="line"><span class="string"> ('b', 'a', 'c'),</span></span><br><span class="line"><span class="string"> ('b', 'c', 'a'),</span></span><br><span class="line"><span class="string"> ('c', 'a', 'b'),</span></span><br><span class="line"><span class="string"> ('c', 'b', 'a')]</span></span><br><span class="line"><span class="string"> """</span></span><br><span class="line">data=itertools.permutations(<span class="string">'001'</span>)</span><br><span class="line">list(data)</span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">[('0', '0', '1'),</span></span><br><span class="line"><span class="string"> ('0', '1', '0'),</span></span><br><span class="line"><span class="string"> ('0', '0', '1'),</span></span><br><span class="line"><span class="string"> ('0', '1', '0'),</span></span><br><span class="line"><span class="string"> ('1', '0', '0'),</span></span><br><span class="line"><span class="string"> ('1', '0', '0')]</span></span><br><span class="line"><span class="string"> """</span></span><br><span class="line"><span class="comment">#permutations输出的是输入对象的全排列，因此对于重复元素会出现重复结果，如('0', '0', '1')。</span></span><br></pre></td></tr></table></figure><h5 id="chain"><a href="#chain" class="headerlink" title="chain"></a>chain</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> itertools</span><br><span class="line">itertools.chain(range(<span class="number">5</span>),range(<span class="number">100</span>,<span class="number">105</span>))</span><br><span class="line"><span class="comment">#输出为迭代器对象：&lt;itertools.chain at 0x7f01d56d1cc0&gt;</span></span><br><span class="line">list(itertools.chain(range(<span class="number">5</span>),range(<span class="number">100</span>,<span class="number">105</span>)))</span><br><span class="line"><span class="comment">#输出：[0, 1, 2, 3, 4, 100, 101, 102, 103, 104]</span></span><br><span class="line">list(itertools.chain(range(<span class="number">3</span>),[<span class="string">'s'</span>,<span class="string">'a'</span>],<span class="string">'124'</span>))</span><br><span class="line"><span class="comment">#输出：[0, 1, 2, 's', 'a', '1', '2', '4']</span></span><br></pre></td></tr></table></figure><h5 id="cycle"><a href="#cycle" class="headerlink" title="cycle"></a>cycle</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> itertools</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> itertools.cycle(<span class="string">'abc'</span>):</span><br><span class="line">    res.append(i)</span><br><span class="line">    <span class="comment">#因为迭代对象无限循环，因此指定输出长度break</span></span><br><span class="line">    <span class="keyword">if</span> len(res)==<span class="number">7</span>:<span class="keyword">break</span></span><br><span class="line">print(res)</span><br><span class="line"><span class="comment">#输出：['a', 'b', 'c', 'a', 'b', 'c', 'a']</span></span><br></pre></td></tr></table></figure><h5 id="count"><a href="#count" class="headerlink" title="count"></a>count</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> itertools</span><br><span class="line">data=itertools.count(<span class="number">10</span>,<span class="number">2</span>)<span class="comment">#初值为10，步长为2</span></span><br><span class="line"><span class="comment">#使用循环遍历迭代结果，因为是无限迭代，所以设定大于20则退出</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> data:</span><br><span class="line">    <span class="keyword">if</span> i&gt;<span class="number">20</span>:<span class="keyword">break</span></span><br><span class="line">    print(i)</span><br><span class="line"><span class="comment">#输出：10  12  14  16  18  20</span></span><br></pre></td></tr></table></figure><h5 id="islice"><a href="#islice" class="headerlink" title="islice"></a>islice</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> itertools</span><br><span class="line">list(itertools.islice(<span class="string">'abcdefg'</span>,<span class="number">2</span>,<span class="number">5</span>))<span class="comment">#起始索引2，终止索引5，默认步长1</span></span><br><span class="line"><span class="comment">#输出：['c', 'd', 'e']</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;包括创建和使用迭代器的函数。&lt;/p&gt;
&lt;p&gt;迭代器是可以记录遍历位置。迭代器对象从集合的第一个元素开始访问，直到所有的元素被访问完结束。迭代器只能往前不会后退。&lt;/p&gt;
&lt;h4 id=&quot;常用函数&quot;&gt;&lt;a href=&quot;#常用函数&quot; class=&quot;headerlink&quot; tit
      
    
    </summary>
    
    
      <category term="python模块" scheme="http://yoursite.com/categories/python%E6%A8%A1%E5%9D%97/"/>
    
    
      <category term="python" scheme="http://yoursite.com/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>calendar 模块</title>
    <link href="http://yoursite.com/2020/02/06/calendar%20%E6%A8%A1%E5%9D%97/"/>
    <id>http://yoursite.com/2020/02/06/calendar%20%E6%A8%A1%E5%9D%97/</id>
    <published>2020-02-06T12:31:52.000Z</published>
    <updated>2020-02-13T05:50:11.991Z</updated>
    
    <content type="html"><![CDATA[<p>包括日历、日期相关函数。</p><h4 id="常用函数"><a href="#常用函数" class="headerlink" title="常用函数"></a>常用函数</h4><p>calendar模块有较多函数，此处仅列举常用函数。calendar返回指定年的日历字符串；month返回指定年月的日历；weekday返回指定日期是星期几；isleap判断指定年是不是闰年；leapdays返回指定年限内闰年的数量。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">calendar.calendar(year,w=2,l=1,c=6,m=3) -&gt; string (multi-line)</span><br><span class="line"><span class="comment">#w表示日之间的间隔宽度，默认间隔2；</span></span><br><span class="line"><span class="comment">#l表示行间隔，默认为1行；</span></span><br><span class="line"><span class="comment">#c表示月之间的间隔宽度，默认为6；</span></span><br><span class="line"><span class="comment">#m表示并列显示的月份数量，默认3个月并排显示</span></span><br></pre></td></tr></table></figure><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">calendar.month(year,month,w=0,l=0) -&gt; string (multi-line)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">calendar.weekday(year, month, day)  -&gt; int</span><br><span class="line"><span class="comment">#注意：默认0表示星期一；0~6：星期一~星期日。</span></span><br></pre></td></tr></table></figure><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">calendar.isleap(year) -&gt; bool</span><br></pre></td></tr></table></figure><p><strong>注意</strong>：闰年包括两种：①公历年份是4的倍数的，且不是100的倍数，比如2020,2004；②公历年份是400的倍数，比如2000。</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">calendar.leapdays(y1, y2) -&gt; int</span><br></pre></td></tr></table></figure><h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h4><h5 id="calendar"><a href="#calendar" class="headerlink" title="calendar"></a>calendar</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> calendar</span><br><span class="line">print(calendar.calendar(<span class="number">2020</span>))</span><br><span class="line"><span class="comment">#结果返回多行字符串，因此需要打印，直接输出可能格式错乱且包括换行符\n.</span></span><br></pre></td></tr></table></figure><h5 id="month"><a href="#month" class="headerlink" title="month"></a>month</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> calendar</span><br><span class="line">print(calendar.month(<span class="number">2020</span>,<span class="number">3</span>))</span><br><span class="line"><span class="comment">#输出：</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">     March 2020</span></span><br><span class="line"><span class="string">Mo Tu We Th Fr Sa Su</span></span><br><span class="line"><span class="string">                   1</span></span><br><span class="line"><span class="string"> 2  3  4  5  6  7  8</span></span><br><span class="line"><span class="string"> 9 10 11 12 13 14 15</span></span><br><span class="line"><span class="string">16 17 18 19 20 21 22</span></span><br><span class="line"><span class="string">23 24 25 26 27 28 29</span></span><br><span class="line"><span class="string">30 31</span></span><br><span class="line"><span class="string">"""</span></span><br></pre></td></tr></table></figure><h5 id="weekday"><a href="#weekday" class="headerlink" title="weekday"></a>weekday</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> calendar</span><br><span class="line">print(calendar.weekday(<span class="number">2020</span>,<span class="number">3</span>,<span class="number">5</span>))</span><br><span class="line"><span class="comment">#输出：3  表示星期四</span></span><br></pre></td></tr></table></figure><h5 id="isleap"><a href="#isleap" class="headerlink" title="isleap"></a>isleap</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> calendar</span><br><span class="line">print(calendar.isleap(<span class="number">2020</span>))</span><br><span class="line"><span class="comment">#输出：True</span></span><br></pre></td></tr></table></figure><h5 id="leapdays"><a href="#leapdays" class="headerlink" title="leapdays"></a>leapdays</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> calendar</span><br><span class="line">print(calendar.leapdays(<span class="number">1900</span>,<span class="number">2020</span>))</span><br><span class="line"><span class="comment">#输出：29  表示[1900,2020)间有29个闰年</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;包括日历、日期相关函数。&lt;/p&gt;
&lt;h4 id=&quot;常用函数&quot;&gt;&lt;a href=&quot;#常用函数&quot; class=&quot;headerlink&quot; title=&quot;常用函数&quot;&gt;&lt;/a&gt;常用函数&lt;/h4&gt;&lt;p&gt;calendar模块有较多函数，此处仅列举常用函数。calendar返回指定年的日历
      
    
    </summary>
    
    
      <category term="python模块" scheme="http://yoursite.com/categories/python%E6%A8%A1%E5%9D%97/"/>
    
    
      <category term="python" scheme="http://yoursite.com/tags/python/"/>
    
  </entry>
  
</feed>
